{"tool_name": "AbstractJarAgent.runJarAgent", "orig_descriptions": [{"description": "Runs the jar agent with the specified options and attaches it to the provided Instrumentation instance. It initializes common parameters, performs test-specific initialization, and starts a special thread for test-specific actions.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"options": {"type": "String", "description": "The options for the jar agent, separated by spaces."}, "inst": {"type": "any", "description": "The Instrumentation instance to which the agent will be attached."}}, "required": ["options", "inst"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Runs a JAR-based agent inside an already-instrumented JVM, using an existing Instrumentation instance. Use this tool when you need to start or control a Java agent that relies on Instrumentation and requires both common and test-specific initialization before test execution.\n\nThis tool is appropriate when: (1) you already have an Instrumentation instance from a premain or agentmain entry point, and (2) you want to configure and launch the agent’s behavior with specific runtime options. It sets up shared (common) parameters, performs any test-specific setup required by the agent, and then starts a dedicated thread responsible for executing test-related or scenario-specific actions during runtime.\n\nThis tool does not create or attach a new JVM, does not obtain Instrumentation by itself, and does not run arbitrary JAR files like a general process launcher. It should not be used for regular application execution or classpath management; it is specifically for managing an already-integrated JAR agent’s lifecycle and behavior via Instrumentation.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:21+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "3916ac9ff6bd0d318dd583b35af5b382429f2a98f1cfd88300be38f17e53f938"}}
{"tool_name": "AbstractTransportSearchableSnapshotsAction.shardOperation", "orig_descriptions": [{"description": "Executes a shard-level operation on a searchable snapshot, ensuring the license is valid and the directory is correctly unwrapped before performing the operation.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"request": {"type": "any", "description": "The request to perform the shard operation."}, "shardRouting": {"type": "any", "description": "The ShardRouting information for the shard on which to perform the operation."}, "task": {"type": "any", "description": "The task associated with the shard operation."}, "listener": {"type": "any", "description": "The ActionListener that will handle the ShardOperationResult asynchronously."}}, "required": ["request", "shardRouting", "task", "listener"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Executes a shard-level operation on a searchable snapshot shard, after verifying that the searchable snapshot feature is licensed and that the underlying directory is correctly unwrapped and ready for access. Use this tool when you need to perform logic that operates on a specific shard of a searchable snapshot, and that logic must only run if licensing and snapshot directory conditions are satisfied.\n\nThis tool is not for index-level, cluster-level, or non-snapshot shards, and it does not manage licenses, create snapshots, or modify cluster state. It should be chosen when an operation is explicitly scoped to a single shard of a searchable snapshot and must safely obtain the proper low-level shard resources before continuing.\n\nThe tool guarantees that, by the time your shard operation runs, the searchable snapshot context is valid and the shard’s directory has been unwrapped from any snapshot-specific wrappers so the operation can interact with it as expected.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:24+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "b30f3900a8480caac259fcd08534290c44d8acb61257e7c2bf3a594597bbff6b"}}
{"tool_name": "AclApi.add_mapping", "orig_descriptions": [{"description": "Adds an Access Control List (ACL) mapping to define permissions for users or groups on specified resources.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["resource_id", "user_id", "permissions"], "properties": {"resource_id": {"type": "string", "description": "The unique identifier for the resource to which the ACL mapping will be applied."}, "user_id": {"type": "string", "description": "The unique identifier of the user or group that the ACL mapping will be associated with."}, "permissions": {"type": "array", "items": {"type": "string"}, "description": "A list of permission strings that define the access level for the user or group on the resource."}, "expiry_date": {"type": "string", "description": "The expiration date for the ACL mapping in the format 'YYYY-MM-DD'. Optional, defaults to null which indicates no expiration.", "default": null}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to create a new ACL mapping that specifies which permissions a user or group has on particular resources. Call it when you need to add or extend access rights, such as granting read, write, or administrative capabilities to a principal for one or more resources.\n\nThis tool is for adding mappings only; it does not modify, remove, or list existing ACL mappings. If you need to update or revoke permissions, or to inspect current ACLs, use the appropriate separate tools instead.\n\nTypical intents include: granting a user access to a project, giving a group edit rights on a dataset, or assigning administrative control over a resource hierarchy. The caller must provide identifiers that clearly specify the target principal and resource(s), along with the intended permission set.\n\nUse this tool when the primary goal is to define new permission relationships between principals and resources in the access control system.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:28+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "f61d91995ea8582b41bd28211179e4c210ae71fdc2c7ea653657af77d7dc1fb3"}}
{"tool_name": "Alarm_1_AddAlarm", "orig_descriptions": [{"description": "Sets a new alarm with specified time and an optional custom name.", "source_files": ["live_multiple"]}, {"description": "Set a new alarm with a specified time and optional custom name.", "source_files": ["live_multiple"]}, {"description": "This function sets a new alarm with a specified time and an optional custom name.", "source_files": ["live_multiple"]}, {"description": "This function sets a new alarm with a specified time and an optional name.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["new_alarm_time"], "properties": {"new_alarm_time": {"type": "string", "description": "The time to set for the new alarm in 24-hour format (e.g., '14:30' for 2:30 PM)."}, "new_alarm_name": {"type": "string", "description": "The custom name to assign to the new alarm.", "default": "New Alarm"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["new_alarm_time"], "properties": {"new_alarm_time": {"type": "string", "description": "The time to set for the new alarm in 24-hour format (HH:MM)."}, "new_alarm_name": {"type": "string", "description": "The custom name to assign to the new alarm.", "default": "New alarm"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["new_alarm_time"], "properties": {"new_alarm_time": {"type": "string", "description": "The time to set for the new alarm in 24-hour format 'HH:MM'."}, "new_alarm_name": {"type": "string", "description": "The name to assign to the new alarm. Helps identify alarms easily.", "default": "New alarm"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["new_alarm_time"], "properties": {"new_alarm_time": {"type": "string", "description": "The time to set for the new alarm, in 24-hour format 'HH:MM'."}, "new_alarm_name": {"type": "string", "description": "The custom name to give to the new alarm.", "default": "New alarm"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["new_alarm_time"], "properties": {"new_alarm_time": {"type": "string", "description": "The time to set for the new alarm, in 24-hour format (HH:MM)."}, "new_alarm_name": {"type": "string", "description": "The label to assign to the new alarm.", "default": "New alarm"}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 60, "num_conversations": 60, "num_as_ground_truth": 6, "aug_description": "Use this tool to create a new one-time alarm for a specific time. It is triggered when the user explicitly wants to be alerted at a particular time, such as “Set an alarm for 7:30 AM” or “Remind me at 18:00 named Workout.” The tool supports specifying the alarm time and, optionally, a custom name or label so the user can distinguish it from other alarms.\n\nThis tool only adds a new alarm; it does not modify, list, or delete existing alarms, and it does not handle recurring schedules (like daily or weekly alarms) unless the recurrence is supported implicitly by the time specification in the underlying system. It should not be used for general reminders, timers, or calendar events that depend on dates or durations rather than a clock time.\n\nChoose this tool when the main intent is: “set/add a new alarm at a given time,” possibly with a descriptive name. Do not use it for snoozing, stopping, or querying alarms; those should be handled by other, more appropriate tools if available.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:32+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "f48c802db64539b90df051f1b597d1645d95d1b8e38415cd104ca9dbae645e85"}}
{"tool_name": "Alarm_1_GetAlarms", "orig_descriptions": [{"description": "Retrieve a list of all alarms that the user has set in the application.", "source_files": ["live_multiple"]}, {"description": "Retrieve a list of alarms that the user has set in the system.", "source_files": ["live_multiple"]}, {"description": "Retrieves a list of alarms that the user has set in the system.", "source_files": ["live_multiple"]}, {"description": "Retrieve a list of alarms that the user has configured on the device, including details such as time, label, and status.", "source_files": ["live_multiple"]}, {"description": "Retrieves the list of alarms that the user has set within the application.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user whose alarms are being retrieved."}, "include_disabled": {"type": "boolean", "description": "A flag indicating whether to include disabled alarms in the result set.", "default": false}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "Unique identifier for the user whose alarms are to be fetched."}, "include_disabled": {"type": "boolean", "description": "Whether to include disabled alarms in the result.", "default": false}, "alarm_type": {"type": "string", "description": "The type of alarms to retrieve.", "enum": ["sound", "vibration", "visual"], "default": "sound"}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "The unique identifier of the user whose alarms are to be retrieved."}, "include_disabled": {"type": "boolean", "description": "A flag indicating whether disabled alarms should be included in the response.", "default": false}, "alarm_type": {"type": "string", "description": "The type of alarms to retrieve, such as 'wake', 'reminder', or 'timer'.", "enum": ["wake", "reminder", "timer"], "default": "wake"}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "The unique identifier of the user whose alarms are to be retrieved."}, "include_disabled": {"type": "boolean", "description": "Flag to include disabled alarms in the list.", "default": false}, "date": {"type": "string", "description": "Filter alarms by the set date, in the format of 'YYYY-MM-DD'. If not provided, defaults to current date.", "default": null}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"user_id": {"type": "integer", "description": "The unique identifier for the user whose alarms are being fetched."}, "include_disabled": {"type": "boolean", "description": "A flag to include alarms that are currently disabled.", "default": false}, "sort_order": {"type": "string", "description": "The order in which the alarms should be sorted.", "enum": ["ascending", "descending"], "default": "ascending"}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 60, "num_conversations": 60, "num_as_ground_truth": 5, "aug_description": "Use this tool when the user wants to see, review, or manage the alarms they have already set in the application. It retrieves and returns the complete list of existing alarms associated with the current user. This may include all alarms regardless of time, label, status (enabled/disabled), or recurrence, depending on how the application stores them.\n\nDo not use this tool to create, modify, or delete alarms; use it only for fetching the current alarm list. Also do not use it for one-time reminders, timers, or notifications that are not modeled as alarms in the application.\n\nTypical user intents include: “What alarms do I have?”, “List my alarms”, “Show all my morning alarms”, or any request where you first need to know which alarms exist before deciding what to change or remove. If follow-up operations (like editing or deleting an alarm) are needed, call this tool first to obtain the relevant alarms and their details, then use the appropriate editing or deletion tool.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:34+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "1b6d6299f8b5278018bc273331ffda36ec6a9d56fe5ef3eb8c21573cce16f936"}}
{"tool_name": "Alltransactions", "orig_descriptions": [{"description": "Retrieve a list of all transactions for a specified statement period.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["statement_period"], "properties": {"statement_period": {"type": "string", "description": "The statement period for which transactions are to be retrieved, in the format 'YYYY-MM'."}, "include_pending": {"type": "boolean", "description": "A flag to determine if pending transactions should be included in the list.", "default": false}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool when you need to retrieve a comprehensive list of all financial transactions that occurred within a specific statement period for an account. It is appropriate when the user asks to see, review, or export everything that was charged, paid, refunded, or adjusted during a given billing cycle or statement range, rather than a single transaction or a small subset. This tool focuses on the time-bounded set of transactions associated with a defined statement period, not real-time or pending activity outside that period. It should be preferred when the request clearly refers to a statement, billing cycle, or historical period summary, such as “show all transactions on my last statement” or “list everything on my May 2024 statement.” It does not modify transactions, create new ones, or analyze them; it only returns the raw list for the specified statement period so that the calling system or assistant can then filter, summarize, or interpret as needed.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:37+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "b81c53865da5882cfa627c16503c6915c7050c00266cc23fc04c9d648daf9c37"}}
{"tool_name": "AltibaseGrantee.prepareObjectsStatement", "orig_descriptions": [{"description": "Prepares a JDBC statement for querying system privileges and their grantors for a given Altibase grantee.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"session": {"type": "any", "description": "The JDBC session in which to prepare the statement."}, "owner": {"type": "any", "description": "The Altibase grantee whose system privileges and grantors are to be queried."}}, "required": ["session", "owner"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to build a JDBC statement that queries system privileges and their grantors for a specific Altibase grantee (user or role). It prepares, but does not execute, the SQL/JDBC statement, so it is typically called before a separate execution step that runs the query and processes results.\n\nCall this tool when the intent is specifically to inspect system-level privileges (not object-level privileges) and to see which principals granted those privileges to the target grantee within an Altibase database. This tool is tailored to Altibase system catalog structures and should not be used for other database products.\n\nDo not use this tool to modify privileges, create or alter users/roles, manage sessions, or perform general SQL queries. It is only for preparing a privilege-inspection statement. If another tool is available for executing statements, fetching results, or handling non-privilege metadata, prefer that other tool instead.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:40+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "1bc204c1699f041e3ccd064895978eb1e6d51fe196ef0d23411c0904d5486db3"}}
{"tool_name": "AmazonGameStore.recommend", "orig_descriptions": [{"description": "Generate game recommendation from Amazon Game Store based on number of players and category.", "source_files": ["multiple", "parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"numOfPlayers": {"type": "integer", "description": "The number of players who will play the game."}, "category": {"type": "string", "description": "The preferred category of board game. E.g. strategy, family, party etc."}, "priceRange": {"type": "string", "description": "The price range you are willing to pay for the board game. E.g. $10-$20, $20-$30 etc. This is an optional parameter. Default ''"}}, "required": ["numOfPlayers", "category"]}, "source_files": ["multiple"]}, {"parameters": {"type": "dict", "properties": {"numOfPlayers": {"type": "integer", "description": "The number of players who will play the game."}, "category": {"type": "string", "description": "The preferred category of board game. E.g. strategy, family, party etc."}, "priceRange": {"type": "string", "description": "The price range you are willing to pay for the board game. E.g. $10-$20, $20-$30 etc. This is an optional parameter. Default to '$10-$20' if not specified."}}, "required": ["numOfPlayers", "category"]}, "source_files": ["parallel_multiple"]}], "source_files": ["multiple", "parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 5, "num_conversations": 2, "num_as_ground_truth": 2, "aug_description": "Use this tool when a user wants recommendations for games specifically from the Amazon Game Store and they care about the number of players and the game category. It selects games that match the requested player count (for example, solo, co-op, or multiplayer based on how the number-of-players input is expressed) and the requested genre or category (such as action, strategy, puzzle, etc.).\n\nChoose this tool when the user’s intent is to discover or explore suitable games, not to purchase, install, or manage existing games. It does not handle non-game products, non-Amazon platforms, detailed price comparisons, or account/order issues. It also does not search broadly across the web; its scope is limited to the Amazon Game Store catalog.\n\nUse this instead of generic search or review tools when the user explicitly asks for game suggestions, recommendations, or options filtered by player count and category from Amazon’s game offerings.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:43+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "3f924e77974104cfe8d5b619caa254f80bd09edc2ed2693c3ed0436b41a1ae86"}}
{"tool_name": "ApplicationAnalyzeApi.get_call_details", "orig_descriptions": [{"description": "Retrieve the details of a specific call using its trace ID and call ID.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["traceId", "callId"], "properties": {"traceId": {"type": "string", "description": "The unique identifier for the trace of the call."}, "callId": {"type": "string", "description": "The unique identifier for the individual call within a trace."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to fetch detailed information about a single, already-recorded application call when you know both its trace ID and its call ID. It is intended for diagnostics, debugging, or auditing of a specific call within a trace, not for listing or searching across multiple calls.\n\nThis tool should be called when the user explicitly refers to a particular call instance (for example, to inspect its metadata, status, timing, or related attributes) and can provide the exact trace ID and call ID. It does not create, modify, or delete calls, and it does not operate on traces without a specific call ID.\n\nDo not use this tool to retrieve summaries, statistics, or collections of calls; choose it only when the goal is to drill down into one known call in a trace and return its full stored details based on the provided identifiers.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:46+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "5fc5899818235e0de46d00a3b4d634984b354e76d5b933faa7dc61f9122c987e"}}
{"tool_name": "ApplicationAnalyzeApi.get_correlated_traces", "orig_descriptions": [{"description": "Retrieve backend trace IDs corresponding to the provided correlation IDs from website and mobile app monitoring data.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["correlationId"], "properties": {"correlationId": {"type": "string", "description": "The unique identifier used for correlating traces between backend and monitoring systems, typically a UUID."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool when you need to map frontend or client-side correlation IDs (from website or mobile app monitoring) to their associated backend trace IDs. It is intended for workflows where you already have one or more correlation IDs from application monitoring and want to locate or analyze the corresponding backend traces in a tracing or observability system.\n\nThis tool only performs the correlation lookup: given correlation identifiers from website or mobile app telemetry, it returns the backend trace IDs that are linked to them. It does not fetch full trace details, logs, metrics, or any other data beyond the correlated trace IDs themselves, and it does not generate or modify correlation IDs.\n\nChoose this tool instead of generic trace search or log query tools when your starting point is known correlation IDs from monitored frontend/mobile sessions and your goal is specifically to identify which backend traces to investigate further.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:49+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "ef59c0945a7b9fe55a109b6a5c7a32e12b055837ecb249b18c772d78fdcbb73a"}}
{"tool_name": "ApplicationAnalyzeApi.get_trace_download", "orig_descriptions": [{"description": "Retrieves detailed information about a trace with a specified ID, allowing for optional pagination.", "source_files": ["live_multiple"]}, {"description": "Retrieves detailed information about a specific trace from an application analysis system by trace ID. The response includes trace data up to a specified retrieval size, starting from a given offset. The data can be filtered based on the time of ingestion.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["id"], "properties": {"id": {"type": "string", "description": "The unique identifier for the trace."}, "retrievalSize": {"type": "integer", "description": "The number of trace entries to retrieve in one call. Defaults to 100 if not specified.", "default": 100}, "offset": {"type": "integer", "description": "The offset from the start of the trace data used for paginating results. Defaults to 0 to start from the beginning.", "default": 0}, "ingestionTime": {"type": "string", "description": "The timestamp representing when the trace was ingested. Format should be in UTC ISO 8601, such as '2023-01-15T00:00:00Z'. If not specified, defaults to the current time.", "default": null}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["id"], "properties": {"id": {"type": "string", "description": "The unique identifier of the trace to retrieve."}, "retrievalSize": {"type": "integer", "description": "The maximum number of trace entries to retrieve.", "default": 100}, "offset": {"type": "integer", "description": "The offset from which to start retrieving trace entries.", "default": 0}, "ingestionTime": {"type": "string", "description": "The ingestion time to filter the trace data, formatted as an ISO 8601 timestamp, such as '2023-03-25T13:00:00Z'.", "default": null}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to retrieve detailed information about a specific trace, identified by its trace ID, and optionally handle large trace data via pagination. This tool is appropriate when the user explicitly refers to a known trace ID and wants to inspect or download its contents, metadata, or segments in a structured way. It is not for listing multiple traces, searching for traces, or creating new traces.\n\nTypical use cases include: drilling into the performance or diagnostic details of a single trace, fetching all parts of a large trace incrementally, or resuming access to a trace when only its ID is available. If the user asks to “get/download this trace by ID”, “see full details for this trace”, or “page through this trace’s data”, this is the correct tool.\n\nDo not use this tool to query summaries, aggregated metrics, or collections of traces; use it only when the primary identifier is a single trace ID and detailed per-trace data is required, possibly across multiple pages.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:53+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "4403632a3e6b8b57879995f99036e2910eb8467d5bb22d94929b816ee3847457"}}
{"tool_name": "ApplicationSettingsApi.get_application_configs", "orig_descriptions": [{"description": "Retrieve all configuration settings for the application, including environment variables, feature toggles, and system behaviors.", "source_files": ["live_multiple"]}, {"description": "Retrieve all configuration settings for the application. This includes settings such as feature toggles, system behaviors, and user preferences.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["environment"], "properties": {"environment": {"type": "string", "description": "The deployment environment for which the application configurations are being retrieved, such as 'development', 'staging', or 'production'.", "enum": ["development", "staging", "production"]}, "include_sensitive": {"type": "boolean", "description": "A flag indicating whether to include sensitive configurations like API keys and passwords. It is recommended to keep this false unless necessary.", "default": false}, "config_type": {"type": "string", "description": "The type of configurations to retrieve, such as 'feature_toggles' or 'system_behaviors'.", "enum": ["all", "feature_toggles", "system_behaviors"], "default": "all"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"environment": {"type": "string", "description": "The application environment for which the configurations are to be fetched, e.g., 'production', 'staging', or 'development'.", "enum": ["production", "staging", "development"], "default": "production"}, "include_sensitive": {"type": "boolean", "description": "Flag to determine if sensitive configurations such as API keys and passwords should be included in the response.", "default": false}}, "required": []}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 0, "aug_description": "Use this tool to retrieve the complete set of configuration settings for the application in a read-only way. It returns all available configuration data, such as environment variables, feature toggles, and system behavior settings, as they are currently defined. This tool is appropriate when you need to inspect or audit how the application is configured, understand which features are enabled or disabled, or diagnose behavior that depends on configuration values.\n\nDo not use this tool to modify, create, or delete any configuration settings; it only reads existing configurations. It does not perform validation, testing, or deployment of configurations, and it does not handle user-specific or session-specific preferences unless those are part of the global application configuration. Choose this tool when the user’s intent is to “get all application configuration values” rather than to update or partially query configurations by specific keys or scopes.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:55+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "88c477ec973204cbd7ae4d471fe7d4770f1570e4d42cf1d00c3abca6efbf28b3"}}
{"tool_name": "ApplicationSettingsApi.get_service_configs", "orig_descriptions": [{"description": "Retrieve a list of all service configurations for the application, including default settings and overrides.", "source_files": ["live_multiple"]}, {"description": "Retrieve all service configurations for the application, including database settings, external service integration details, and feature flags.", "source_files": ["live_multiple"]}, {"description": "Retrieve the configuration settings for all services managed by the application.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": [], "properties": {"service_name": {"type": "string", "description": "The name of the specific service to retrieve configurations for, such as 'database' or 'cache'. If omitted, configurations for all services will be returned.", "default": "all"}, "include_defaults": {"type": "boolean", "description": "A flag to determine whether to include the application's default service configurations in the response.", "default": true}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": [], "properties": {"environment": {"type": "string", "description": "The deployment environment for which the service configurations are requested, such as 'development', 'staging', or 'production'.", "enum": ["development", "staging", "production"], "default": "production"}, "include_sensitive": {"type": "boolean", "description": "A flag to determine whether sensitive information like passwords and API keys should be included in the configurations.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": [], "properties": {"service_name": {"type": "string", "description": "The name of the service to filter the configurations. If omitted, configurations for all services are returned.", "default": "all"}, "include_sensitive": {"type": "boolean", "description": "Flag to determine if sensitive information such as passwords or tokens should be included in the configurations.", "default": false}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 3, "num_conversations": 3, "num_as_ground_truth": 0, "aug_description": "Use this tool to fetch all service configuration objects defined for the application. It returns a list that may include both default configuration settings and any overrides that are currently in effect. Call this when you need to inspect or reason about how different services within the application are configured, such as for validation, display, audit, or decision-making based on current settings. This tool is read-only: it does not modify, create, or delete any configurations, and it does not apply or test configurations. It does not retrieve user-specific preferences or runtime status/health of services; it only returns the stored configuration data for services at the application level. Choose this tool over others when the goal is to see the complete configuration landscape for services, rather than updating settings or managing a single service’s configuration.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:31:57+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "f45383ab7c775d41941743975176a39cee7dc2141fde5a17f278121afd533ee1"}}
{"tool_name": "ApplicationSettingsApi.order_service_config", "orig_descriptions": [{"description": "Configure the order of services for an application according to specified preferences.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["service_order"], "properties": {"service_order": {"type": "array", "items": {"type": "string"}, "description": "An ordered list of service identifiers that define the sequence in which services should be arranged."}, "user_id": {"type": "integer", "description": "The unique identifier of the user for whom the service order is being configured.", "default": null}, "preserve_existing": {"type": "boolean", "description": "A flag indicating whether to preserve the existing service order if one exists. If set to 'false', the existing order will be overwritten.", "default": true}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to set or update the ordering of services within an application when you have specific preferences about which services should come first or later. This is typically used when an application has multiple services (for example, different integrations, features, or modules) and their processing or display order matters for behavior, priority, or user experience.\n\nCall this tool when the user explicitly wants to rearrange, prioritize, or re-sequence services for an application, based on a desired order they provide or describe. It should be used after the relevant services already exist for that application.\n\nThis tool does not create, delete, or modify the configuration of individual services themselves; it only changes their relative order. It also does not select which services are enabled or disabled, nor does it apply global application settings beyond service ordering. Choose this tool over others when the main intent is to control sequence or priority among existing services within a specific application.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:00+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "b67823d8e9d10c7cc494df2bd9962acdebfd258f8ab1483d537187539fd0bd0a"}}
{"tool_name": "Attack", "orig_descriptions": [{"description": "Performs an automated penetration test against the specified host.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["url"], "properties": {"url": {"type": "string", "description": "The URL of the host to attack, including the protocol (e.g., 'http://example.com')."}, "attack_type": {"type": "string", "description": "The type of attack to perform.", "enum": ["SQL Injection", "Cross-site Scripting", "Denial of Service", "Brute Force"], "default": "Brute Force"}, "port": {"type": "integer", "description": "The port number to target on the host. Default is the standard port for the service.", "default": 80}, "verbose": {"type": "boolean", "description": "Flag indicating whether to run the attack in verbose mode, providing detailed output.", "default": false}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to automatically run a penetration test against a specific target host when the user explicitly wants to assess security or discover vulnerabilities. The primary input is the host to be tested; ensure the host is valid and that the user has authorization to test it. The tool actively probes the target, simulating attacker behavior to identify weaknesses, misconfigurations, or exploitable services.\n\nDo not use this tool for simple connectivity checks, port scans, log review, vulnerability explanation, or remediation advice; it specifically performs an automated penetration test rather than passive analysis or reporting only. It should be selected when the user intent is to “attack,” “pentest,” or “security test” a host in an automated manner, not when they just want theoretical guidance or manual testing steps.\n\nThis tool does not configure the target, fix vulnerabilities, or manage broader security programs. It focuses solely on executing the penetration test against the given host and returning the results of that test.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:03+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "2c39277230fea7ac165f4af29baadbad599fbf3a899b924f28360f862c866ad1"}}
{"tool_name": "B", "orig_descriptions": [{"description": "This complex function initializes a task queue with customizable concurrency, task addition, and event handling capabilities. It allows for synchronous and asynchronous task execution, pausing and resuming the queue, and handling various queue events.", "source_files": ["simple_javascript"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"e": {"type": "any", "description": "The initial task or an array of tasks to be added to the queue. Default null"}, "t": {"type": "float", "description": "The concurrency level of the task queue."}, "n": {"type": "float", "description": "The payload size for each task worker. Optional parameter. Default 0.0"}}, "required": ["t"]}, "source_files": ["simple_javascript"]}], "source_files": ["simple_javascript"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to manage and execute a sequence of tasks through a task queue with configurable behavior. Call this when the user wants to run multiple tasks (sync or async) with controlled concurrency, the ability to pause or resume processing, and to react to queue-related events (such as task start, completion, or errors). This tool is appropriate when the user describes needing a “queue,” “worker pool,” “concurrent task runner,” or “job processor,” rather than running a single task in isolation.\n\nThis tool initializes and configures the queue; it is not for submitting one-off operations without queue semantics, and it does not itself implement business logic for the tasks. Instead, it orchestrates how tasks are scheduled, how many run at the same time, and how task lifecycle events are exposed or handled. Prefer other tools if the user only needs a single function call, simple delay, or basic parallelism without queue features such as pausing, resuming, or event-driven handling.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:07+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "834133f388671c049d90e27d36b3e6a612f58f5f2662edeea562256c9fe693c7"}}
{"tool_name": "BadgeApi.get_project_policy_violations_badge1", "orig_descriptions": [{"description": "Generates a badge image indicating the number of policy violations for a specified project and version.", "source_files": ["live_multiple"]}, {"description": "Retrieves a badge indicating the policy violations status for a specified project and version.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["project_name", "project_version"], "properties": {"project_name": {"type": "string", "description": "The unique name of the project for which the badge is being requested."}, "project_version": {"type": "string", "description": "The specific version of the project to check for policy violations."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["name", "version"], "properties": {"name": {"type": "string", "description": "The unique name identifier of the project for which the policy violations badge is requested."}, "version": {"type": "string", "description": "The version identifier of the project for which the policy violations badge is requested."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need a visual badge image that displays how many policy violations exist for a specific project and version. It is intended for integrating compliance or quality status into dashboards, README files, or other visual reports where a concise indicator of violations is needed.\n\nThis tool takes a project identifier and a version identifier (as defined by the calling context) and returns an image representing the current count of policy violations for that combination. It does not list, describe, or modify violations; it only summarizes them as a single badge-style image.\n\nDo not use this tool to retrieve detailed violation data, metadata, or to manage policies. Choose this tool over others when the goal is to present a simple, graphical overview of policy violation counts, not to perform analysis or configuration changes.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:09+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "19eb8b38afe7ca3995d56839fbfc151238e125bb1a22d2ab1cf6b684769cd37c"}}
{"tool_name": "BankStatementOverView", "orig_descriptions": [{"description": "Provides an overview of a bank statement, including account information and a summary of transactions for a specific period.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["bank_name", "account_number", "account_type", "full_name", "transaction_overview"], "properties": {"bank_name": {"type": "string", "description": "The official name of the bank as it appears on the bank statement."}, "account_number": {"type": "string", "description": "The unique identifier for the account, typically found at the top of the statement."}, "account_type": {"type": "string", "description": "The classification of the account, such as 'checking', 'savings', or 'credit'.", "enum": ["checking", "savings", "credit", "loan", "investment"]}, "full_name": {"type": "string", "description": "The complete name of the account holder as recorded by the bank."}, "transaction_overview": {"type": "dict", "description": "A summary of transactions within the statement period, including totals and counts.", "properties": {"total_deposits": {"type": "float", "description": "The total amount deposited in the account during the statement period, in dollars."}, "total_withdrawals": {"type": "float", "description": "The total amount withdrawn from the account during the statement period, in dollars."}, "start_date": {"type": "string", "description": "The starting date of the statement period, in the format 'YYYY-MM-DD'."}, "end_date": {"type": "string", "description": "The ending date of the statement period, in the format 'YYYY-MM-DD'."}}}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when the user wants a concise, structured overview of a bank statement for a specific period, rather than detailed per-transaction analysis. It should be chosen when the intent is to understand overall account status, key account information, and a high-level summary of activity (such as total credits, total debits, and net change) during the requested timeframe. This tool focuses on summarizing the statement, not on performing complex analytics, categorization, forecasting, anomaly detection, or cross-account comparisons. It does not modify any data; it only reads and summarizes. Prefer this tool over any transaction-level or analytics tool when the user asks for a summary, overview, snapshot, or quick understanding of their bank statement or account activity across a defined period.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:12+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "1ef85ac366bc6dc0a1974348be29cb1525df4dd9c5c49afe8162e76754ce3443"}}
{"tool_name": "BaseMarkupSerializer.surrogates", "orig_descriptions": [{"description": "Processes surrogate pairs in XML content, ensuring they are valid XML characters and serializes them appropriately, handling cases both inside and outside of CDATA sections.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"high": {"type": "integer", "description": "The high surrogate value of the surrogate pair."}, "low": {"type": "integer", "description": "The low surrogate value of the surrogate pair."}, "inContent": {"type": "boolean", "description": "A flag indicating whether the surrogate pair is within XML content."}}, "required": ["high", "low", "inContent"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Handles XML Unicode surrogate pairs during serialization. Use this tool when you need to validate and serialize characters represented as surrogate pairs (typically non‑BMP Unicode code points) in XML content. It checks that surrogate pairs form valid XML characters and converts them into the correct serialized form. This includes content in both normal text nodes and within CDATA sections, ensuring that resulting XML remains well‑formed and uses only allowed character ranges. This tool should be selected when the primary concern is correctness and legality of Unicode surrogate handling in XML output, not for general XML parsing, structural manipulation, entity resolution, or schema validation. It does not alter XML structure, element names, attributes, or namespaces, and it does not perform encoding conversion beyond what is required to serialize valid surrogate pairs as proper XML characters.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:15+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "dd928d563c660acdfc0a71670b413f5044bf706b9b86f0260f5c63d9a74b56ad"}}
{"tool_name": "BasePolicyDataProvider.getRegistryPolicyValue", "orig_descriptions": [{"description": "Retrieves the value of a specified property from the DBeaver registry policy node if it exists, specifically for Windows systems.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"root": {"type": "any", "description": "The root key in the Windows registry (e.g., HKEY_LOCAL_MACHINE)."}, "property": {"type": "String", "description": "The name of the property to retrieve the value for from the registry."}}, "required": ["root", "property"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to read a specific policy/property value from the DBeaver registry policy node on Windows systems. It looks up a single named property in the relevant Windows registry location used by DBeaver policy management and returns its value if the property exists.\n\nThis tool should be chosen when the user intent is: “Given a known policy/property name, tell me what value is currently set in the DBeaver registry policy on Windows.” It does not modify or create registry entries, does not manage policies, and does not provide default values if a property is missing. It is strictly for retrieval, not for validation, parsing, or interpretation of the policy semantics.\n\nDo not use this tool for non-Windows platforms, for reading configuration from files, databases, or environment variables, or for enumerating all available policies. It only targets an existing, specific registry-based policy value associated with DBeaver on Windows.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:18+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "2df83b76b3f9499e49fac2bb63eb141a745daa5980e64674d2e11bacc4110a17"}}
{"tool_name": "Basic.checkSizes", "orig_descriptions": [{"description": "Checks if the sizes of various views of the environment map match the expected size and if the map's empty status is consistent with the expected size.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"environ": {"type": "HashMap", "description": "The environment variable map to check."}, "size": {"type": "integer", "description": "The expected size of the environment variable map."}}, "required": ["environ", "size"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Validates consistency between an environment map’s declared size and the actual sizes of its internal views, as well as whether the map is empty or non-empty as expected. Use this tool when you need to verify that all size-related aspects of an environment map are coherent before further processing, simulation, or display. It checks that each view of the environment map matches the expected dimensions and that the “empty” status (e.g., no elements or data present) logically follows from those dimensions. This tool is for diagnostics and validation only: it does not modify the environment map, fix inconsistencies, or compute new sizes. Call this when you suspect size mismatches, before running operations that assume a correct map layout, or after constructing or loading an environment map to ensure it is structurally consistent.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:20+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "8fa833915d87964a449858395e0cc17e0ffc0eb2ccf2fcd84d13f651789461fc"}}
{"tool_name": "BattleReignGameAPI.update_player_equipment", "orig_descriptions": [{"description": "Modify the player's equipment level for specified attributes", "source_files": ["parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"attribute": {"type": "string", "description": "The attribute of the equipment to modify."}, "level": {"type": "integer", "description": "The level to modify the attribute to."}, "playerID": {"type": "integer", "description": "Player ID of the player. Default to 123", "default": 123}}, "required": ["attribute", "level"]}, "source_files": ["parallel_multiple"]}], "source_files": ["parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 3, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to change a player’s equipment level for one or more specific equipment-related attributes in Battle Reign (for example, upgrading or downgrading a weapon, armor piece, or similar gear attribute level). The intent is to adjust an existing player’s equipment levels, not to create new equipment, remove equipment, or modify unrelated player data such as stats, inventory counts, or cosmetics.\n\nCall this tool when the user explicitly requests changing how strong or advanced a piece of equipment is (e.g., “set my sword to level 10” or “lower my helmet upgrade level”) for an already known player. Do not use this tool for reading equipment data, listing a player’s gear, or performing combat, matchmaking, or progression logic. It strictly updates the stored level value(s) of specified equipment attributes for a given player ID or equivalent identifier, assuming those attributes already exist in the game’s data model.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:23+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "058ad06297d8f0f183ee4845d63701ec3548bfa2f2569a0ae0b4806d3f8938d8"}}
{"tool_name": "BoardGameGeek.recommend", "orig_descriptions": [{"description": "Generate game recommendation from BoardGameGeek store based on number of players and category.", "source_files": ["multiple", "parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"numPlayers": {"type": "integer", "description": "The number of players who will play the game."}, "category": {"type": "string", "description": "The preferred category of board game. E.g. strategy, family, party etc."}, "difficulty": {"type": "string", "description": "Preferred difficulty level. E.g. beginner, intermediate, advanced etc. This is an optional parameter. Default 'beginner'"}}, "required": ["numPlayers", "category"]}, "source_files": ["multiple"]}, {"parameters": {"type": "dict", "properties": {"numPlayers": {"type": "integer", "description": "The number of players who will play the game."}, "category": {"type": "string", "description": "The preferred category of board game. E.g. strategy, family, party etc."}, "difficulty": {"type": "string", "description": "Preferred difficulty level. E.g. beginner, intermediate, advanced etc. This is an optional parameter. Default to 'beginner' if not specified."}}, "required": ["numPlayers", "category"]}, "source_files": ["parallel_multiple"]}], "source_files": ["multiple", "parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 5, "num_conversations": 2, "num_as_ground_truth": 3, "aug_description": "Use this tool to recommend a board game from the BoardGameGeek store when the user specifies how many people will play and what type of game they want. This tool is appropriate when the main intent is: “Suggest a board game that fits my group size and preferred category,” drawing directly from BoardGameGeek’s catalog.\n\nThe tool focuses on two key inputs: the number of players and the game category (such as family, strategy, party, etc., depending on what the user describes). It then selects a suitable game recommendation matching those constraints.\n\nDo not use this tool for rules explanations, strategy tips, reviews, or detailed information about a specific game the user already named. Do not use it to search by game mechanisms, play time, complexity, or other criteria unless they can be reasonably mapped to a category and player count. Choose this tool when the user wants a concrete game suggestion to buy or consider from BoardGameGeek, based primarily on group size and category preferences.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:26+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "0c6c3dc914ef97aa8623e2791378b1bb2f7773c3cff76c380db296e02d5c135f"}}
{"tool_name": "Booleans.parseBooleanLenient", "orig_descriptions": [{"description": "Parses a string to a boolean value leniently, allowing various string representations to be interpreted as 'false', and defaults to 'true' for other cases, unless a default value is provided.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"value": {"type": "String", "description": "The string value to parse into a boolean."}, "defaultValue": {"type": "boolean", "description": "The default boolean value to return if the string value is null."}}, "required": ["value", "defaultValue"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Converts a string to a boolean in a lenient way. Use this tool when you have free-form or inconsistent textual boolean input and need to interpret many variants of “false” explicitly. It recognizes several string representations as false (for example typical negative or off-like values, exact set defined by the implementation). All other non-null, non-recognized values are treated as true by default, unless you provide an explicit default value via the defaultValue argument. When defaultValue is given and the input cannot be clearly mapped (according to the tool’s internal rules), that defaultValue is returned instead of assuming true. This tool should be chosen over strict parsers when user input may be messy, loosely formatted, or not strictly \"true\"/\"false\". It does not validate or normalize arbitrary text beyond deciding which boolean to return, and it does not handle non-string types directly; those should be converted to string before calling this tool.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:29+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "d79b5814ed758584d2c8aeacab820239bed186aa14893369ef6e9e75aa178453"}}
{"tool_name": "Buses_3_BuyBusTicket", "orig_descriptions": [{"description": "This function processes the purchase of bus tickets from a departure city to a destination city on a specified date and time. It also accounts for the number of passengers and additional luggage options.", "source_files": ["live_multiple"]}, {"description": "Purchase bus tickets for a specified route, date, and time with the option to include additional luggage.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Purchases bus tickets from a specified departure city to a given destination on a set date and time, with the option to include additional luggage.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Facilitates the purchase of bus tickets from one city to another on a specified date and time, with an option for additional luggage.", "source_files": ["live_multiple"]}, {"description": "Purchase bus tickets for a specified route, date, and time. Options for the number of passengers and additional luggage are available.", "source_files": ["live_multiple"]}, {"description": "This function processes the purchase of bus tickets from a specified departure city to a destination city on a given date and time, for a certain number of passengers with an option to include additional luggage.", "source_files": ["live_multiple"]}, {"description": "This function enables the user to purchase bus tickets by providing details such as departure and destination cities, departure date and time, the number of passengers, and the option to carry additional luggage.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time", "num_passengers"], "properties": {"from_city": {"type": "string", "description": "The city where the journey begins, in the format of 'City, State', such as 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city for the trip, in the format of 'City, State', such as 'Los Angeles, CA'."}, "departure_date": {"type": "string", "description": "The departure date in 'YYYY-MM-DD' format, for example, '2023-04-21'."}, "departure_time": {"type": "string", "description": "The time of departure in 24-hour format 'HH:MM', such as '14:30' for 2:30 PM."}, "num_passengers": {"type": "integer", "description": "The number of passengers for whom the tickets are being purchased. Must be a positive integer."}, "additional_luggage": {"type": "boolean", "description": "Indicates whether additional luggage will be carried on the bus.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city of origin for the trip, such as 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city for the trip, such as 'Boston, MA'."}, "departure_date": {"type": "string", "description": "The date of departure in the format 'YYYY-MM-DD'."}, "departure_time": {"type": "string", "description": "The time of departure in 24-hour format 'HH:MM'."}, "num_passengers": {"type": "integer", "description": "The number of passengers for whom the tickets are being purchased.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "Indicates whether additional luggage space is required.", "default": false}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city to depart from, e.g., 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city of the trip, e.g., 'Los Angeles, CA'."}, "departure_date": {"type": "string", "description": "The date of departure in the format of 'YYYY-MM-DD'."}, "departure_time": {"type": "string", "description": "The time of departure in 24-hour format, e.g., '14:00'."}, "num_passengers": {"type": "integer", "description": "The number of tickets for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "Whether to carry excess baggage in the bus. True for yes, false for no.", "default": false}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city from which the bus will depart."}, "to_city": {"type": "string", "description": "The destination city for the bus trip."}, "departure_date": {"type": "string", "description": "The departure date for the trip, in the format 'YYYY-MM-DD'."}, "departure_time": {"type": "string", "description": "The departure time for the trip, in the format 'HH:MM' (24-hour clock)."}, "num_passengers": {"type": "integer", "description": "The number of passengers for whom tickets need to be purchased.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "Indicates whether additional luggage will be carried on the bus.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city to depart from, such as 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city of the trip, such as 'Boston, MA'."}, "departure_date": {"type": "string", "description": "The date of departure, in the format of 'YYYY-MM-DD'."}, "departure_time": {"type": "string", "description": "The time of departure, in 24-hour format 'HH:MM'."}, "num_passengers": {"type": "integer", "description": "The number of tickets for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "An option to carry excess baggage in the bus.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city where the journey will start, in the format of 'City, State', such as 'Berkeley, CA' and 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city for the trip, in the format of 'City, State', such as 'Los Angeles, CA' and 'Chicago, IL'."}, "departure_date": {"type": "string", "description": "The date of departure, in the format of 'YYYY-MM-DD', such as '2023-04-15'."}, "departure_time": {"type": "string", "description": "The time of departure in 24-hour format, such as '14:00' for 2 PM."}, "num_passengers": {"type": "integer", "description": "The number of passengers for whom the tickets are to be purchased.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "Indicator of whether additional luggage will be carried on the bus.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city where the journey will start. The city name should be in the format of 'City, State', such as 'Los Angeles, CA'."}, "to_city": {"type": "string", "description": "The destination city of the trip. The city name should be in the format of 'City, State', such as 'New York, NY'."}, "departure_date": {"type": "string", "description": "The date of departure, in the format of 'YYYY-MM-DD'."}, "departure_time": {"type": "string", "description": "The time of departure, in the 24-hour format 'HH:MM'."}, "num_passengers": {"type": "integer", "description": "The number of tickets to purchase for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "Indicates whether the passenger will carry additional luggage beyond the standard allowance.", "default": false}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 69, "num_conversations": 66, "num_as_ground_truth": 3, "aug_description": "Use this tool when the user explicitly wants to buy or book bus tickets for a specific trip. It processes a concrete purchase, not just searching or comparing routes. The tool handles trips defined by a departure city, a destination city, and a specific travel date and time. It also considers how many passengers are traveling and whether extra luggage options are needed as part of the ticket purchase.\n\nDo not use this tool for general schedule inquiries, price estimation without purchase intent, route exploration, or changes/cancellations to existing bookings. It should be called only after the user has decided on a particular bus trip and is ready to proceed with buying tickets for that selection.\n\nChoose this tool over any generic bus search or information tools when the user’s goal is to complete a ticket purchase, including specifying passenger count and luggage needs for the selected journey.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:32+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "4383978a73e647b408b99ab3dac49ef18da1b4cf1b343b8840d007147f2d13fc"}}
{"tool_name": "Buses_3_FindBus", "orig_descriptions": [{"description": "Search for a bus itinerary between two cities on a specific date.", "source_files": ["live_multiple"]}, {"description": "Search for a bus itinerary between two specified cities on a given date.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Search for a bus itinerary between two cities on a specified date, considering the number of passengers and route category.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Searches for bus itineraries between two cities on a specified date and accommodates a certain number of passengers.", "source_files": ["live_multiple"]}, {"description": "Search for a bus itinerary between two cities on a specified date. The search can be filtered based on the number of passengers and the bus route category.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city of departure, in the format 'City, State', such as 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city of the trip, in the format 'City, State', such as 'Los Angeles, CA'."}, "departure_date": {"type": "string", "description": "The date of departure in the format 'YYYY-MM-DD'."}, "num_passengers": {"type": "integer", "description": "The number of passengers for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The category of the trip based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city to depart from, in the format of 'City, State' (e.g., 'Los Angeles, CA')."}, "to_city": {"type": "string", "description": "The destination city of the trip, in the format of 'City, State' (e.g., 'New York, NY')."}, "departure_date": {"type": "string", "description": "The date of departure, in the format 'YYYY-MM-DD' (e.g., '2023-04-15')."}, "num_passengers": {"type": "integer", "description": "The number of tickets required for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The type of bus route based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The name of the city where the journey begins, such as 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city for the trip, such as 'Los Angeles, CA'."}, "departure_date": {"type": "string", "description": "The departure date for the trip, in the format 'YYYY-MM-DD'."}, "num_passengers": {"type": "integer", "description": "The number of passengers traveling, ranging from 1 to 5.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The category of the bus route based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city to depart from, in the format of 'City, State', such as 'Austin, TX'."}, "to_city": {"type": "string", "description": "The destination city of the trip, in the format of 'City, State', such as 'Dallas, TX'."}, "departure_date": {"type": "string", "description": "The date of departure in the format 'YYYY-MM-DD', such as '2023-04-15'."}, "num_passengers": {"type": "integer", "description": "The number of passengers for whom tickets are to be booked. Must be a positive integer.", "default": 1}, "category": {"type": "string", "description": "The category of the bus trip based on the number of stops en route.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city of departure, in the format of 'City, State', such as 'Berkeley, CA'."}, "to_city": {"type": "string", "description": "The destination city of the trip, in the format of 'City, State', such as 'Los Angeles, CA'."}, "departure_date": {"type": "string", "description": "The date of departure in the format of 'YYYY-MM-DD', such as '2023-04-15'."}, "num_passengers": {"type": "integer", "description": "The number of passengers for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The category of the trip based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city of departure, formatted as 'City, State' (e.g., 'San Francisco, CA')."}, "to_city": {"type": "string", "description": "The destination city, formatted as 'City, State' (e.g., 'Los Angeles, CA')."}, "departure_date": {"type": "string", "description": "The date of departure, formatted as 'MM/DD/YYYY' (e.g., '04/25/2023')."}, "num_passengers": {"type": "integer", "description": "The number of passengers for which to book the trip. Must be an integer from 1 to 5.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The type of bus route, indicating the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city of departure, formatted as 'City, State' (e.g., 'New York, NY')."}, "to_city": {"type": "string", "description": "The destination city, formatted as 'City, State' (e.g., 'Los Angeles, CA')."}, "departure_date": {"type": "string", "description": "The date of departure in the format 'YYYY-MM-DD' (e.g., '2023-06-15')."}, "num_passengers": {"type": "integer", "description": "The number of passengers for the trip.", "enum": [1, 2, 3, 4, 5], "default": "1"}, "category": {"type": "string", "description": "The type of bus route based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city to depart from, in the format of 'City, State (abbr)' (e.g., 'Los Angeles, CA')."}, "to_city": {"type": "string", "description": "The destination city of the trip, in the format of 'City, State (abbr)' (e.g., 'New York, NY')."}, "departure_date": {"type": "string", "description": "The date of departure, in the format 'YYYY-MM-DD' (e.g., '2023-04-15')."}, "num_passengers": {"type": "integer", "description": "The number of tickets required for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The type of bus route based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The name of the city where the journey begins, such as 'New York, NY'. Use short form for state"}, "to_city": {"type": "string", "description": "The destination city for the trip, such as 'Los Angeles, CA'. Use short form for state"}, "departure_date": {"type": "string", "description": "The departure date for the trip, in the format 'YYYY-MM-DD'."}, "num_passengers": {"type": "integer", "description": "The number of passengers traveling, ranging from 1 to 5.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The category of the bus route based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 69, "num_conversations": 66, "num_as_ground_truth": 17, "aug_description": "Use this tool when the user wants to find or compare bus travel options between two cities for a specific calendar date. It searches available bus itineraries for intercity travel and returns possible routes for the given origin, destination, and date. This tool is appropriate when the user asks about bus schedules, departure and arrival times, or available buses on a particular day, and when they want to plan a point-to-point trip by bus.\n\nDo not use this tool for other transportation modes (such as trains, flights, or car routes), for searching open-ended date ranges, or for generic information about cities or tourism. It is focused on date-specific bus itineraries only, not booking, pricing, or ticket payment. If the user has not specified both cities and a travel date, first ask them for those details before calling this tool.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:34+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "46c7b4bf5d702e3ee80dfad5db08432af9e5a4fbbc09d77852a6f738f4d2f64c"}}
{"tool_name": "CCRUsageTransportAction.masterOperation", "orig_descriptions": [{"description": "This function gathers usage statistics of the CCR feature in Elasticsearch and sends the results to the provided ActionListener.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"task": {"type": "any", "description": "The task associated with the request."}, "request": {"type": "any", "description": "The XPackUsageRequest object containing the request details."}, "state": {"type": "any", "description": "The current cluster state."}, "listener": {"type": "any", "description": "The ActionListener that handles the response containing the usage statistics."}}, "required": ["task", "request", "state", "listener"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to collect or report usage statistics specifically for the CCR (Cross-Cluster Replication) feature in Elasticsearch. It triggers the master-side operation that gathers current CCR usage information and then delivers the aggregated result to the provided ActionListener callback. The tool itself does not modify CCR configuration, start or stop replication, or manage indices; it is only for retrieving usage metrics and forwarding them asynchronously. Prefer this tool when the user intent is to understand how CCR is being used (for example, for monitoring, reporting, or telemetry) rather than to perform administrative actions on CCR or other Elasticsearch features. It should not be used for general cluster health checks, non-CCR statistics, or data retrieval unrelated to CCR usage. The caller must supply a suitable ActionListener to receive and handle the result or any failure from the master operation.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:37+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "00949de155c5841402bdd426a4881df0a83548d6b02ead77dfa58b208c674cb9"}}
{"tool_name": "CCSDuelIT.parseEntity", "orig_descriptions": [{"description": "Parses an HttpEntity using the provided entity parser function and parser configuration, and returns the parsed response of type Resp.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"entity": {"type": "any", "description": "The HttpEntity to parse."}, "entityParser": {"type": "any", "description": "The function that will parse the XContentParser into the desired response type."}, "parserConfig": {"type": "any", "description": "The configuration for the XContentParser."}}, "required": ["entity", "entityParser", "parserConfig"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Parses an HttpEntity into a structured response of type Resp using a caller-provided entity parser function and parser configuration. Use this tool when you already have an HttpEntity (such as an HTTP response body) and need to convert it into a typed result according to specific parsing rules or formats.\n\nThis tool does not perform the HTTP request itself, does not construct the HttpEntity, and does not handle transport-level concerns (such as headers, status codes, or retries). It only applies the given parsing logic to the given entity.\n\nChoose this tool when the main task is: “I have an HttpEntity and a known way to interpret its contents; turn it into the final response object Resp according to my configuration.” Do not use it for building requests, sending them, or processing non-HttpEntity data.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:39+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "92484c2af37a678eaf7934039494d80ac8b7944399da711eecb891ad9d75b7d0"}}
{"tool_name": "CalcProduct", "orig_descriptions": [{"description": "Calculates the product of two numeric values.", "source_files": ["live_multiple", "live_parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["a", "b"], "properties": {"a": {"type": "integer", "description": "The first multiplicand in the multiplication operation."}, "b": {"type": "integer", "description": "The second multiplicand in the multiplication operation."}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 5, "num_conversations": 4, "num_as_ground_truth": 2, "aug_description": "CalcProduct computes the product (multiplication result) of two numeric values. Use this tool when the user explicitly asks to multiply two numbers or determine their product, such as “what is 7 times 8?” or “multiply 3.5 and 2.”\n\nThis tool should be selected when exactly two numeric inputs are involved in a straightforward multiplication task. It is not intended for adding, subtracting, dividing, exponentiation, or for operations involving more than two values. If the user asks for other arithmetic operations, or multi-step calculations that are not just a single multiplication of two values, another more appropriate tool should be chosen.\n\nInvoke CalcProduct only when both inputs are numeric and multiplication is clearly requested or implied. The tool returns a single numeric result representing the product of the two inputs.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:42+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "b112da960d49dcca85b7920dddca4285d30bff7c579efc7e5f39b2e222d7705d"}}
{"tool_name": "Catphish.generate_phishing_domains", "orig_descriptions": [{"description": "Generate a list of potential phishing domains based on the provided domain to help identify possible phishing attacks.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["domain"], "properties": {"domain": {"type": "string", "description": "The target domain for which to generate possible phishing variants."}, "tld": {"type": "string", "description": "The top-level domain to be used for generating phishing domains, such as 'com', 'org', 'net'.", "enum": ["com", "org", "net", "info", "biz"], "default": "com"}, "strategy": {"type": "string", "description": "The strategy to use for generating phishing domains, such as 'typo' for typographical errors or 'homoglyph' for similar-looking characters.", "enum": ["typo", "homoglyph", "subdomain", "hyphenation"], "default": "typo"}, "limit": {"type": "integer", "description": "The maximum number of phishing domain variants to generate.", "default": 10}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool when you need to generate possible phishing or lookalike domains derived from a specific legitimate domain, in order to assess phishing risk, monitor for abuse, or support security investigations. The tool takes a single domain as input and returns a list of variant domains that attackers might register, such as those created by character substitutions, common misspellings, added or removed words, or similar visual patterns. It is intended for threat modeling, defensive monitoring, and security analysis, not for creating domains to be actually used. This tool does not check domain registration status, DNS records, hosting details, or email configurations, and it does not perform any active scanning or external lookups. It only suggests candidate phishing domains based on the structure of the provided domain. Choose this tool when the primary goal is to anticipate or enumerate deceptive domains that resemble a known target domain.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:45+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "dbf93df96ef418dd6d1472009fe9a252db34853394bdfeed4a78e79314514b94"}}
{"tool_name": "ChaDri.change_drink", "orig_descriptions": [{"description": "Modifies the existing drink order to accommodate the customer's new request, ensuring the drink is updated according to the specified preferences.", "source_files": ["live_multiple", "live_parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["new_preferences"], "properties": {"drink_id": {"type": "string", "description": "The unique identifier of the drink to be changed.", "default": "0000-0000-0000"}, "new_preferences": {"type": "dict", "description": "The updated preferences for the drink order.", "properties": {"size": {"type": "string", "description": "The size of the drink the customer prefers.", "enum": ["small", "medium", "large"], "default": "medium"}, "temperature": {"type": "string", "description": "The temperature at which the drink should be served.", "enum": ["cold", "warm", "hot"], "default": "cold"}, "sweetness_level": {"type": "string", "description": "The sweetness level the customer requests for the drink.", "enum": ["none", "light", "regular", "extra"], "default": "regular"}, "milk_type": {"type": "string", "description": "The type of milk to be used in the drink, if applicable.", "enum": ["regular", "soy", "almond", "coconut"], "default": "regular"}, "special_instructions": {"type": "string", "description": "Any additional instructions provided by the customer for the drink preparation.", "default": ""}}}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["drink_id", "new_preferences"], "properties": {"drink_id": {"type": "string", "description": "The unique identifier of the drink to be changed."}, "new_preferences": {"type": "dict", "description": "The updated preferences for the drink order.", "properties": {"size": {"type": "string", "description": "The size of the drink the customer prefers.", "enum": ["small", "medium", "large"], "default": "medium"}, "temperature": {"type": "string", "description": "The temperature at which the drink should be served.", "enum": ["cold", "warm", "hot"], "default": "cold"}, "sweetness_level": {"type": "string", "description": "The sweetness level the customer requests for the drink.", "enum": ["none", "light", "regular", "extra"], "default": "regular"}, "milk_type": {"type": "string", "description": "The type of milk to be used in the drink, if applicable.", "enum": ["regular", "soy", "almond", "coconut"], "default": "regular"}, "special_instructions": {"type": "string", "description": "Any additional instructions provided by the customer for the drink preparation.", "default": ""}}}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 4, "num_conversations": 3, "num_as_ground_truth": 3, "aug_description": "Use this tool when the user wants to change an already selected or previously discussed drink, rather than creating a new order from scratch. It updates the existing drink order to reflect new preferences, such as different size, type of milk, flavor adjustments, temperature, or other customizations that the user explicitly requests. This tool assumes there is an existing drink context to modify; it does not create a brand-new drink order if none has been chosen yet. Do not use this tool for adding food items, side orders, or additional separate drinks; it is only for altering the current drink. The outcome should be a revised drink configuration that matches the user’s updated instructions and replaces the prior version of that drink in the order, while preserving any existing details the user has not changed.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:47+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "41917fa0c2899c7ae36a8e5d51163b8967a39320d7dea741e43faffd70e88c75"}}
{"tool_name": "ChaFod", "orig_descriptions": [{"description": "Changes the food item based on the customer's request, allowing for modifications to the ingredients or preparation method.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Changes the selection of food based on the customer's request, ensuring the food name provided is in uppercase as per the requirement.", "source_files": ["live_simple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["foodItem"], "properties": {"foodItem": {"type": "string", "description": "The name of the food item to be modified as requested by the customer."}, "newIngredients": {"type": "string", "description": "A comma-separated list of new ingredients to include in the food item, if any.", "default": ""}, "removeIngredients": {"type": "string", "description": "A comma-separated list of ingredients to remove from the food item, if any.", "default": ""}, "specialInstructions": {"type": "string", "description": "Special preparation instructions provided by the customer, such as 'extra spicy' or 'no salt'.", "default": ""}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["TheFod"], "properties": {"TheFod": {"type": "string", "description": "The name of the food to be changed, provided in uppercase letters only (e.g., 'PIZZA', 'BURGER').", "enum": ["PIZZA", "BURGER", "SALAD", "SOUP", "STEAK"]}}}, "source_files": ["live_simple"]}], "source_files": ["live_multiple", "live_parallel_multiple", "live_simple"], "task_types": ["single_turn"], "num_occurrences": 8, "num_conversations": 7, "num_as_ground_truth": 5, "aug_description": "Handles customer requests to modify a food item’s composition or preparation method. Use this tool when the user wants to change ingredients (add, remove, substitute), adjust portion elements, or alter how an item is cooked or assembled (e.g., grilling instead of frying, sauce on the side, no salt). It should be called when the intent is to adapt an existing dish to fit preferences, dietary needs, or restrictions rather than to create a completely new menu item. This tool focuses on changing what is included in the food item and how it is prepared, not on pricing, nutrition analysis, order placement, or inventory management. Choose this tool over others when the core task is: “Take this dish and tweak its ingredients or cooking method according to the customer’s instructions.”", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:50+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "a8c9492b5749244d5a67dc7d19e5dbd273cba060902eaedd3f130a246b8c4a27"}}
{"tool_name": "ChartSeriesGenerator", "orig_descriptions": [{"description": "This function creates a new ChartSeries with customizable settings for axis labels, data points, and color schemes, and attaches it to a given chart layout.", "source_files": ["simple_javascript"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"labels": {"type": "array", "items": {"type": "String"}, "description": "The labels for the chart's axis."}, "data": {"type": "array", "items": {"type": "String"}, "description": "The data points for the series."}, "color": {"type": "String", "description": "The default color for the series. Optional parameter."}, "chartLayout": {"type": "dict", "description": "The layout object of the chart where the series will be added."}}, "required": ["labels", "data", "chartLayout"]}, "source_files": ["simple_javascript"]}], "source_files": ["simple_javascript"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to generate and attach a new data series to an existing chart layout, with control over how that series is displayed. It creates a ChartSeries object and configures its visual and labeling properties, such as axis labels, data point definitions, and color schemes, then links it to the specified chart layout. This is appropriate when the user intent is to add or modify a series in a chart rather than to create an entirely new chart or update global chart settings.\n\nThis tool does not build complete charts from scratch, manage datasets outside the series being created, or handle chart-wide styling, legends, or interactivity beyond what is intrinsic to the series itself. It also does not perform data analysis or transformation; it assumes that the data points provided are already in the desired form. Choose this tool when the task focuses on customizing how a particular set of values appears within an existing chart structure.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:52+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "7f1dc8fdf6b1ec4f888678169e6b634452d76fa0cb5dbd1fc4c0816daa38f27a"}}
{"tool_name": "ClassFileFinder.findClassFile", "orig_descriptions": [{"description": "Finds the class file for a given class name within the specified class path and returns the path to the class file.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"name": {"type": "String", "description": "The fully qualified name of the class to find."}, "classPath": {"type": "String", "description": "The class path where to search for the class file, with paths separated by the system path separator."}}, "required": ["name", "classPath"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to locate the physical .class file corresponding to a specific class name on a given class path. The tool takes a class name and a class path (or equivalent configuration, as defined by the calling context) and searches through that class path to find where the compiled class file resides. It returns the path to the class file that matches the requested class name.\n\nThis tool is for lookup and resolution only: it does not read, parse, decompile, load, or execute the class, and it does not modify the file system or any archives. It should be chosen when the user’s intent is to map a logical class name to its underlying compiled file location, for tasks such as inspection, analysis, or further processing by other tools. If the request involves anything beyond finding and returning the file path (such as analyzing bytecode or running the class), this is not the appropriate tool.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:55+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "003a2d1f9331eff7aef34b70440881bcbfbd51c89a421ffd8aa41a91f36ce0dd"}}
{"tool_name": "ClientAddress.set_address", "orig_descriptions": [{"description": "Sets the full address for a client profile.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["full_address"], "properties": {"full_address": {"type": "string", "description": "The complete address of the client, including street, city, state, and postal code, in the format 'Street, City, State, Postal Code' (e.g., '1234 Elm St, Springfield, IL, 62704')."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to set or update the complete physical address associated with a client profile in one operation. Call this when you need to define or overwrite the client’s full address record, rather than changing individual components separately. This tool should be chosen when the user intent is to store a definitive, current address for contact, billing, shipping, or identification purposes.\n\nThis tool does not handle partial updates unless they are explicitly supported by its arguments; it expects you to provide all required address-related fields as arguments in a single call. It does not create or select the client itself, process payments, validate identity, or perform address verification beyond storing the provided data. Make sure the correct client profile is already identified or in context before calling this tool, and then supply the address details exactly as required by the arguments.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:32:57+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "6e9e3b037b64c3883cf7a444949d6af64478a42d9dec3a1dcaa06d2c2892d6dc"}}
{"tool_name": "Cloudflare_Bypass", "orig_descriptions": [{"description": "This tool is used to bypass Cloudflare protection in order to retrieve the true IP address of a webpage.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["domain"], "properties": {"domain": {"type": "string", "description": "The domain whose true IP address needs to be retrieved."}, "user_agent": {"type": "string", "description": "The User-Agent string to be used in the header of the request. It represents the device and browser that is making the request.", "default": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"}, "timeout": {"type": "integer", "description": "The timeout value for the request in seconds.", "default": 30}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "This tool attempts to discover the underlying server IP address that is hidden behind Cloudflare protection for a given webpage or domain. Use this tool when a user explicitly wants to identify the origin IP and not just resolve the Cloudflare edge IPs. It is intended for diagnostic, research, or migration scenarios where knowing the real hosting IP is required (for example, to verify hosting provider, check DNS configuration, or plan a move off Cloudflare).\n\nDo not use this tool for general web browsing, content scraping, performance testing, or ordinary DNS lookups; choose other tools for those tasks if available. This tool focuses specifically on revealing the “true” backend IP rather than interacting with the site’s content or bypassing authentication, rate limits, or other access controls.\n\nThe typical trigger for this tool is a user request such as “find the real IP behind this Cloudflare-protected site” or “what is the origin server IP for this domain?”", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:08+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "98906381ee03d1f8e16c02155f225bf32a0770373deafc10e29d0a5795e657a5"}}
{"tool_name": "CompositeRuntimeField.createChildRuntimeField", "orig_descriptions": [{"description": "Attempts to create a child runtime field for a composite field, but since composite fields cannot have children, it throws an IllegalArgumentException.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"parserContext": {"type": "any", "description": "The context used for parsing the mapping."}, "parent": {"type": "String", "description": "The name of the parent field."}, "parentScriptFactory": {"type": "any", "description": "A factory function to create a script for the parent composite field."}, "onScriptError": {"type": "any", "description": "The strategy for handling script errors."}}, "required": ["parserContext", "parent", "parentScriptFactory", "onScriptError"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool only when the user explicitly attempts to create or query a child runtime field on a composite field and you must reflect that this operation is invalid. This method represents an operation that always fails: composite runtime fields cannot have child runtime fields, and any attempt to create one results in an IllegalArgumentException. Do not use this tool to actually construct or configure fields; it does not create or modify any data or schema. Instead, choose this tool to signal, explain, or reason about why child runtime fields are not allowed for composite fields, or when you need to model or describe the behavior of code that would throw this exception in such a scenario. If the user expects successful field creation, this tool is not appropriate; select a different tool that supports valid field creation instead.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:11+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "7cd20267cf88dbaf21f43fa5f7679041c7b408952209a6da989d6a0cab9ad681"}}
{"tool_name": "ConsoleAnnotator.annotate", "orig_descriptions": [{"description": "Processes the given MarkupText for the specified context using a chain of ConsoleAnnotators, updating or removing annotators as necessary.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"context": {"type": "any", "description": "The context in which the MarkupText is being annotated."}, "text": {"type": "any", "description": "The MarkupText to be annotated."}}, "required": ["context", "text"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to process and transform console-oriented MarkupText for a specific context by running it through a chain of ConsoleAnnotators. It takes already-structured MarkupText (not raw strings) and applies context-aware annotations such as styling, highlighting, or other console-related markup adjustments. The tool may update the existing annotator chain or remove annotators that are no longer relevant to the given context.\n\nCall this tool when you need to adapt or re-annotate MarkupText for a new or changed console context (for example, different output modes, themes, or environments) rather than when you are initially generating the MarkupText content itself. Do not use this tool to parse plain text into markup, to render markup to a final display format, or to perform non-console-related transformations. It is specifically for refining or reconfiguring existing console markup annotations based on the provided processing context.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:13+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "584a88e44022161ab134b55c23a9301f7f3458b916c07ae27f843b583c60f248"}}
{"tool_name": "ControlAppliance.execute", "orig_descriptions": [{"description": "This function is designed for controlling a home appliance, checking its current status and settings, as well as monitoring indoor air properties like air quality and temperature. For control commands, the input must clearly specify 'power on' or 'start'. To check the status, the input must include the keyword '확인'. Note that this tool is not intended for describing, creating, deleting, or removing modes or routines.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Controls a home appliance, checks its current status and settings, and monitors indoor air properties such as air quality and temperature. The command must be explicit, using 'power on' or 'start' for control actions and 'check' for status inquiries. Mode or routine management is not supported by this function.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["command"], "properties": {"command": {"type": "string", "description": "The command must be specified as a string in Korean, consisting of the room name, appliance name (or alias), and operation command, separated by commas. Examples: '거실, 에어컨, 실행' for turning on the air conditioner in the living room, ', 에어컨, 냉방 실행' for activating cooling without specifying the room, '다용도실, 통돌이, 중지' for stopping the washing machine (alias '통돌이') in the utility room.", "enum": ["거실, 에어컨, 실행", ", 에어컨, 냉방 실행", "다용도실, 통돌이, 중지"]}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["command"], "properties": {"command": {"type": "string", "description": "The operation command for an appliance, optionally preceded by a room name and followed by the appliance name or alias. The command should be separated by commas. For example, 'main room, air conditioner, turn on' to power on the air conditioner in the main room, 'None, air conditioner, cool' to set the air conditioner to cool mode without specifying a room, and 'laundry room, tongdonly, stop' to stop the tongdonly appliance in the laundry room.", "enum": ["power on", "start", "stop", "check", "turn on", "cool"]}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 22, "num_conversations": 19, "num_as_ground_truth": 7, "aug_description": "Use this tool when the user wants to directly control a specific home appliance, check its current operating status or settings, or get indoor air information (such as air quality and temperature) related to that appliance.\n\nInvoke this tool only if the user’s request includes a clear control or status-check intent. For control commands, the user’s input must explicitly include a phrase equivalent to “power on” or “start” (e.g., turning the appliance on or starting its operation). For status inquiries, the input must include the Korean keyword “확인” to indicate that the user wants to check current status or settings.\n\nDo not use this tool for creating, describing, modifying, deleting, or removing modes, routines, or automations. It does not design new behaviors; it only operates or queries existing appliance functions and related indoor air properties. If the user only asks for general information or explanations without controlling or checking a specific appliance, do not call this tool.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:16+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "9c39a93383ef522cbb97910abd9211f0e9e6858ed57e64ef039082a0aa52de93"}}
{"tool_name": "CookieHeaderTest.create", "orig_descriptions": [{"description": "Creates a DummyServer instance with SSL support using the provided socket address and SSL context.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"sa": {"type": "any", "description": "The socket address to bind the server to. This is an InetSocketAddress object that has a constructor taking first field as ip address, such as 192.168.1.1, as a string and taking second field is socket address such as 8000"}, "sslContext": {"type": "any", "description": "The SSL context to be used for creating the server socket. "}}, "required": ["sa", "sslContext"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to start a local dummy HTTPS server for testing HTTP cookie and header behavior. CookieHeaderTest.create sets up a DummyServer instance that listens on the given network socket address and is configured with the provided SSL context so that connections use SSL/TLS.\n\nCall this tool when your intent is to run tests or checks that require an actual SSL-enabled server endpoint, for example to observe how clients send, receive, or manage cookies and headers over secure connections. It does not perform any HTTP requests itself, does not inspect or modify cookies, and does not manage client behavior; it only creates and configures the server side.\n\nChoose this tool instead of non-SSL or generic server tools when SSL/TLS is required for your test scenario. The caller is responsible for providing a valid socket address and SSL context and for handling any further server lifecycle, such as starting, stopping, or interacting with the created DummyServer instance.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:18+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "b4c7bbfeff89a4e32dedd421ecd9b49dc709d36a0cd2138b10368f9e1cea7c14"}}
{"tool_name": "CoroutineManager.co_exit_to", "orig_descriptions": [{"description": "This function switches the execution from one coroutine to another within the CoroutineManager, passing an argument object to the target coroutine. It also checks if the target coroutine is available and throws an exception if not.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"arg_object": {"type": "any", "description": "The argument object to pass to the target coroutine."}, "thisCoroutine": {"type": "integer", "description": "The ID of the currently active coroutine."}, "toCoroutine": {"type": "integer", "description": "The ID of the coroutine to switch to."}}, "required": ["arg_object", "thisCoroutine", "toCoroutine"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to immediately transfer execution from the currently running coroutine to a specified target coroutine managed by CoroutineManager, while passing a single argument object to that target. This is effectively a controlled context switch between coroutines already registered with the CoroutineManager.\n\nThe function checks whether the target coroutine is available and in a valid state to receive control. If the target is not available, it raises an exception instead of performing the switch. This makes it suitable when you explicitly know which coroutine should run next and you need to provide it with data at the moment of switching.\n\nDo not use this tool to create, register, or destroy coroutines, or to schedule them automatically; it only handles direct, explicit transitions between existing coroutines and enforces availability checks on the target before switching.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:20+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "f073b9d3f732c40af90b8ca58e7ccd1fc850b98c5499dcc1e958384515215d57"}}
{"tool_name": "Crawler.scan", "orig_descriptions": [{"description": "Scans the specified host to retrieve information about its web directories and parameters used when a user requests specific details about domain directories.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["host"], "properties": {"host": {"type": "string", "description": "The domain name or IP address of the host to be scanned."}, "port": {"type": "integer", "description": "The port number to connect to on the host, default is HTTP port 80.", "default": 80}, "timeout": {"type": "float", "description": "The timeout for the scan in seconds. If not specified, defaults to 10 seconds.", "default": 10.0}, "user_agent": {"type": "string", "description": "The User-Agent string to be used in the HTTP requests during the scan. Defaults to a standard web browser User-Agent string.", "default": "Mozilla/5.0 (compatible; CrawlerBot/2.1)"}, "follow_redirects": {"type": "boolean", "description": "Determines whether to follow HTTP redirects (3xx responses). Defaults to true.", "default": true}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Performs an automated scan of a specified host to discover its web-accessible directories and the URL parameters used when clients request resources under those directories. Use this tool when the user wants structural information about a domain’s web content, such as paths, endpoints, and associated query parameters. This tool is suited for mapping how a website is organized and which parameters are involved in requests, not for fetching page content, executing arbitrary HTTP requests, or analyzing response bodies. It should be chosen when the goal is reconnaissance of a site’s directory layout and parameter usage rather than interacting with individual URLs or performing content-based analysis. The scan focuses on web directories and request parameters only; it does not perform security testing, vulnerability assessment, or non-web network scanning (such as ports, services, or protocols beyond HTTP/HTTPS).", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:22+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "735ee6f1f9f8e9d9dbac12bff45490ab40e0f4aa952f5548add43983fbc6f564"}}
{"tool_name": "Crypto_tool.encrypt_decrypt", "orig_descriptions": [{"description": "Encrypt, encode, and decode text using a specified cryptographic method and encoding type.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["text", "method"], "properties": {"text": {"type": "string", "description": "The text to be encrypted, encoded, or decoded."}, "key": {"type": "string", "description": "The secret key used for encryption. Must be a string of appropriate length for the chosen encryption method.", "default": "defaultkey123"}, "crypto": {"type": "string", "description": "The type of encryption algorithm to use.", "enum": ["AES", "DES", "3DES", "RSA"], "default": "AES"}, "mode": {"type": "string", "description": "The encryption mode to use with the cryptographic algorithm.", "enum": ["CBC", "CFB", "OFB", "CTR", "ECB", "GCM"], "default": "CBC"}, "method": {"type": "string", "description": "The operation to perform: encrypting, encoding, or decoding the text.", "enum": ["encrypt", "encode", "decode"]}, "encoding": {"type": "string", "description": "The type of encoding to use for the input/output text, such as 'utf-8' or 'base64'.", "default": "utf-8"}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool when you need to encrypt, decrypt, encode, or decode text using a specific cryptographic method and encoding scheme. Call this tool when the user explicitly asks to protect data (encrypt), recover original data (decrypt), or convert between raw text and encoded formats (encode/decode) with a named method (for example, a cipher or hash-like method) and a defined encoding type (such as base variants or similar encodings, if supported by the tool’s arguments).\n\nDo not use this tool for general text processing, data analysis, key generation, or secure key management. It is only for transforming given text according to the requested cryptographic and encoding parameters. The caller is responsible for providing any required keys, passwords, or method names via the tool’s arguments, and for choosing the correct operation (encryption vs. decryption vs. encoding/decoding). If the user’s request does not clearly specify a cryptographic method or encoding type that matches the available arguments, ask for clarification instead of guessing.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:25+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "aafe907fa20f6d31147c63b2e06956cfcb8de4f5b5a2780d785448fbd3c195b5"}}
{"tool_name": "CustomDashboardsApi.add_custom_dashboard", "orig_descriptions": [{"description": "This function creates a new custom dashboard with a specified configuration and adds it to the system.", "source_files": ["live_multiple"]}, {"description": "This function adds a new custom dashboard to the system. It allows users to create a personalized view with widgets and data relevant to their needs.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["dashboard_name", "widgets", "layout"], "properties": {"dashboard_name": {"type": "string", "description": "The name of the custom dashboard to be created."}, "widgets": {"type": "array", "items": {"type": "string"}, "description": "A list of widget identifiers to be included in the dashboard."}, "layout": {"type": "string", "description": "The layout configuration for the dashboard.", "enum": ["grid", "freeform", "single"]}, "description": {"type": "string", "description": "A brief description of the dashboard's purpose and contents.", "default": "No description provided."}, "is_public": {"type": "boolean", "description": "A flag indicating whether the dashboard should be public or private.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["dashboard_name", "user_id"], "properties": {"dashboard_name": {"type": "string", "description": "The name of the new custom dashboard."}, "user_id": {"type": "integer", "description": "The unique identifier of the user for whom the dashboard is being created."}, "widgets": {"type": "array", "items": {"type": "string"}, "description": "A list of widget identifiers to be included in the custom dashboard.", "default": []}, "layout": {"type": "string", "description": "The layout format of the dashboard.", "enum": ["grid", "single_column", "multi_column"], "default": "grid"}, "theme": {"type": "string", "description": "The visual theme of the dashboard.", "enum": ["light", "dark"], "default": "light"}, "refresh_rate": {"type": "integer", "description": "The rate at which the dashboard data refreshes, in seconds.", "default": 60}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 0, "aug_description": "Use this tool to create and register a new custom dashboard in the system. It should be called when the user wants to define a dashboard layout, content, or configuration that does not yet exist, and then make it available for later viewing or management. The tool expects a complete configuration describing the new dashboard; it does not infer or generate configuration on its own. It only adds new dashboards and does not update, delete, or retrieve existing dashboards. If the user’s intent is to modify an existing dashboard, get a list of dashboards, or view dashboard data, do not use this tool. Choose this tool specifically when the user is explicitly asking to \"create\", \"add\", or \"set up\" a new custom dashboard with a provided configuration that should be stored by the system.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:27+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "c350995b6ced47b7de3a0096e9d4552c00571df1b8b30685948aca4a32cdd21f"}}
{"tool_name": "CustomDashboardsApi.delete_custom_dashboard", "orig_descriptions": [{"description": "Deletes a specific custom dashboard identified by its unique ID.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["customDashboardId"], "properties": {"customDashboardId": {"type": "string", "description": "The unique identifier of the custom dashboard to be deleted."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to permanently delete a specific custom dashboard when you know its unique identifier. This is appropriate when a user explicitly requests removal of a dashboard they no longer need or wants to clean up obsolete or test dashboards. The operation targets exactly one dashboard, identified only by its ID, and removes it from the system so it is no longer available for viewing, editing, or sharing.\n\nDo not use this tool to update, rename, or retrieve a dashboard; it is only for deletion. It also does not list dashboards or create new ones. Before calling this tool, the calling context must already have the correct dashboard ID and should ensure the user has confirmed they want to delete it, since the action may be irreversible depending on the surrounding system behavior.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:30+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "bcd17cc6a5ddd2ca7b52637be58bcf0e37f5ae7f10de10ca23c99c41153ddac3"}}
{"tool_name": "CustomDashboardsApi.get_custom_dashboard", "orig_descriptions": [{"description": "Retrieve the details of a custom dashboard by its unique identifier.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["customDashboardId"], "properties": {"customDashboardId": {"type": "string", "description": "The unique identifier of the custom dashboard to retrieve."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to retrieve full details of a single existing custom dashboard when you already know its unique identifier. Call this tool when the user wants to view, inspect, or verify the configuration, metadata, or current definition of a specific custom dashboard, rather than listing multiple dashboards or creating/updating one. This tool expects the ID of the target dashboard and returns its stored details so the assistant can answer questions like “what does this dashboard contain?” or “show me the configuration for dashboard X.” Do not use this tool to search for dashboards by name, filter, or other attributes, and do not use it to modify or delete dashboards. Choose this tool only when the intent is to look up one known dashboard by its identifier and get its current state.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:32+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "df57da2641d5abaebe2118da6f03e68974d018559758ec25c94043f91e39a542"}}
{"tool_name": "CustomDashboardsApi.get_custom_dashboards", "orig_descriptions": [{"description": "Retrieves a list of custom dashboards that the user has access to, based on the provided query parameters.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["query"], "properties": {"query": {"type": "string", "description": "A search query string to filter accessible dashboards. Supports logical operators and field-specific filtering."}, "pageSize": {"type": "integer", "description": "The number of dashboard entries to return per page.", "default": 10}, "page": {"type": "integer", "description": "The page number to retrieve, used for paginating through large sets of dashboard entries.", "default": 1}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to retrieve a list of custom dashboards the current user is allowed to access. It returns only dashboards that match the provided query parameters, such as filters on ownership, accessibility, or other supported criteria (as defined by the underlying API), and that the user has permission to see.\n\nCall this tool when you need to list or browse available custom dashboards, populate a dashboard selection UI, or check what dashboards a user can work with. It is read-only: it does not create, modify, delete, or reorder dashboards, and it does not return data or metrics contained within the dashboards themselves.\n\nDo not use this tool to fetch detailed configuration of a single dashboard, to update dashboard settings, or to manage access permissions. Prefer this tool over others when the main goal is to obtain a filtered collection of dashboards visible to the user rather than to perform actions on a specific dashboard.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:35+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "78f9397886e063a108cac3fb1b0e4f1e13ddb9cc68ce6e75a4f3e1b76627cf65"}}
{"tool_name": "CustomDashboardsApi.get_shareable_api_tokens", "orig_descriptions": [{"description": "Retrieves a list of shareable API tokens associated with the custom dashboards.", "source_files": ["live_multiple"]}, {"description": "Retrieve a list of shareable API tokens associated with the user's account. This can be used to grant third-party services access to the user's dashboard data without exposing personal credentials.", "source_files": ["live_multiple"]}, {"description": "Retrieve a list of shareable API tokens associated with the user's account.", "source_files": ["live_multiple"]}, {"description": "Retrieve a list of all shareable API tokens associated with the user's account. These tokens can be used to grant access to custom dashboards.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "The unique identifier of the user whose API tokens are to be retrieved."}, "include_expired": {"type": "boolean", "description": "Determines whether to include expired tokens in the response.", "default": false}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {}, "required": []}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "The unique identifier of the user whose API tokens are to be retrieved."}, "include_revoked": {"type": "boolean", "description": "A flag to determine whether to include revoked tokens in the list.", "default": false}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 9, "num_conversations": 9, "num_as_ground_truth": 2, "aug_description": "Use this tool to list all shareable API tokens that are associated with custom dashboards. Call this when the user wants to see which tokens currently exist for sharing dashboards externally or programmatically, for auditing which tokens are active, or for managing dashboard sharing at a higher level before performing actions with individual tokens.\n\nThis tool only retrieves and returns existing shareable API tokens related to custom dashboards. It does not create, update, delete, or validate tokens, and it does not modify any dashboard settings or permissions. It also does not return non-shareable tokens or tokens unrelated to custom dashboards.\n\nChoose this tool when the intent is to inspect or review shareable tokens for custom dashboards, such as checking what is available to use in links, integrations, or automation. Do not use this tool for any operation that changes token state or dashboard configuration; use other specialized tools for those actions if available.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:37+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "d1f662b06760d43b452087c066737196a704a1587a2baeab547d6d32b2947011"}}
{"tool_name": "DB2Tablespace.resolveTablespaceReference", "orig_descriptions": [{"description": "Resolves a tablespace reference, which can be a name or a direct reference, to a DB2Tablespace object using the provided data source.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"monitor": {"type": "any", "description": "The progress monitor to track the operation progress."}, "dataSource": {"type": "any", "description": "The DB2DataSource object used to access the database."}, "reference": {"type": "any", "description": "The tablespace reference, which can be a name (String) or a direct DB2Tablespace reference."}}, "required": ["monitor", "dataSource", "reference"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Resolves a DB2 tablespace reference into a concrete DB2Tablespace object using the current data source context. Use this tool when you have a tablespace identifier that may be either a logical name (string) or an existing direct reference/handle, and you need a unified DB2Tablespace object to proceed with further operations (such as inspection, configuration, or dependency analysis).\n\nThis tool is for disambiguating or normalizing a tablespace reference, not for creating, altering, or dropping tablespaces, and not for querying or modifying table data. It does not perform validation beyond what is needed to map the input reference to a DB2Tablespace, and it does not change any database state.\n\nChoose this tool when the user intent is: “Given this tablespace reference (name or object), get the corresponding DB2Tablespace object from the current data source so I can use it consistently in later steps.” Do not use it for general database discovery, listing all tablespaces, or executing SQL.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:40+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "63cc2310fbcfd851fcefc92537063cedaa31e94bdaaa6c9c0d85084b9bd73e8b"}}
{"tool_name": "DB2ViewBaseDepCache.prepareObjectsStatement", "orig_descriptions": [{"description": "Prepares a JDBC statement for querying metadata of a specific DB2 view in a given schema.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"session": {"type": "any", "description": "The JDBCSession object representing the active database session."}, "db2ViewBase": {"type": "any", "description": "The DB2ViewBase object representing the DB2 view for which the statement is being prepared."}}, "required": ["session", "db2ViewBase"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to construct and obtain a JDBC prepared statement that will query metadata for a specific DB2 view within a particular schema. It is intended for situations where you already know the target schema and view and want a reusable, parameterized statement rather than directly executing the query. This tool focuses only on preparing the statement; it does not execute the query, fetch results, or interpret metadata. It should be chosen when the next steps in your workflow will handle statement execution and result processing separately. Do not use this tool for creating, altering, or dropping views, nor for querying table data or non-DB2 databases. It is specifically about metadata access for DB2 views at the statement-preparation stage, within the context of a view dependency or cache management system.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:42+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "7e513899897656b9b75dfec05bd00515c5b18fb9f45e8bf7973496c177dabfe8"}}
{"tool_name": "DateScriptFieldType.createFieldType", "orig_descriptions": [{"description": "Creates a new field type for a date script with the provided parameters.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"name": {"type": "String", "description": "The name of the field."}, "factory": {"type": "any", "description": "The factory to create the date field script."}, "script": {"type": "any", "description": "The script to define the date field behavior."}, "meta": {"type": "HashMap", "description": "The metadata for the field type."}, "onScriptError": {"type": "any", "description": "The policy on how to handle script errors."}}, "required": ["name", "factory", "script", "meta", "onScriptError"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to define or register a new custom field type specifically for date-based scripts. It creates a field type configuration that can then be referenced or used elsewhere in the system wherever date script field types are required. This tool is appropriate when the user intent is to introduce a new kind of date field behavior or representation, not to modify, delete, or query existing field types. It should not be used to update values of fields, execute scripts, or perform date calculations at runtime; it only defines the field type itself. Choose this tool over more general field or script tools when the key aspect is that the field type is dedicated to handling dates in a script context and must be created from scratch with the given parameters.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:44+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "3896db40960e45a22a4738df1e6a5445fa35ed82f0751dbf8340c13f3b2fac9d"}}
{"tool_name": "DesAPITest.init", "orig_descriptions": [{"description": "Initializes the DES cipher with the specified algorithm, mode, and padding scheme.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"crypt": {"type": "String", "description": "The encryption algorithm to use, such as 'DES' or 'DESede'."}, "mode": {"type": "String", "description": "The cipher mode to use, such as 'CBC' or 'ECB'."}, "padding": {"type": "String", "description": "The padding scheme to use, such as 'PKCS5Padding' or 'NoPadding'."}}, "required": ["crypt", "mode", "padding"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Initializes a DES cipher instance for later encryption or decryption operations. Use this tool when you need to set up a DES-based cryptographic context by choosing the algorithm variant, block mode, and padding scheme before any data is processed. This initialization typically precedes calls to separate tools or methods that perform the actual encrypt/decrypt actions.\n\nThis tool is only for configuration of the DES cipher; it does not encrypt or decrypt data by itself, does not manage keys, and does not handle input/output streams or files. It should be selected over other cipher initialization tools only when the DES algorithm is specifically required. If another tool configures a different algorithm (such as AES or RSA), do not use this one.\n\nCall this tool when the user intent is: “Set up a DES cipher with a particular algorithm string, cipher mode, and padding scheme so that subsequent operations can use this configured instance.”", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:47+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "2b5b13a36713ddac1ebbe680a44ee9718b7a200ed14856b075a1d7625863d3bb"}}
{"tool_name": "DurationImpl.alignSigns", "orig_descriptions": [{"description": "Aligns the signs of BigDecimal elements in a subarray to be consistent with each other, potentially borrowing from adjacent elements to adjust values and maintain the overall magnitude.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"buf": {"type": "Array", "description": "The array of BigDecimal elements representing different units of time whose signs need to be aligned.", "items": {"type": "any"}}, "start": {"type": "integer", "description": "The starting index of the subarray to align signs."}, "end": {"type": "integer", "description": "The ending index of the subarray to align signs."}}, "required": ["buf", "start", "end"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "AlignSigns should be used when you have an array (or subarray) of BigDecimal values representing a decomposed quantity (for example, duration components) and you need all elements in that subarray to have consistent sign (all non‑negative or all non‑positive), while preserving the overall combined magnitude. This tool adjusts individual elements and may \"borrow\" from adjacent elements within the specified subarray so that sign inconsistencies (such as mixed positive and negative components) are resolved without changing the net value of the group.\n\nUse this tool when the user intent is to normalize the sign distribution across related BigDecimal components, not to recompute or rescale their total. It does not perform arithmetic beyond what is necessary to rebalance signs, does not validate semantics of the values (such as units or ranges), and does not sort, truncate, or extend the array. Choose this tool when you must keep the aggregate numeric effect intact but require sign consistency across elements.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:51+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "232c6d88c8077a2a04bd4e16cb8b598d531ea1df126bac547fcf8267c06e4e3c"}}
{"tool_name": "DynamicChartGenerator", "orig_descriptions": [{"description": "This function creates a dynamic chart based on user input, applies a scaling factor to the axis values, and integrates the chart into a specified dashboard for display.", "source_files": ["simple_javascript"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"userData": {"type": "array", "items": {"type": "String"}, "description": "The data provided by the user to plot on the chart."}, "scalingFactor": {"type": "float", "description": "A scaling factor applied to the chart's axis values. Optional parameter."}, "dashboard": {"type": "any", "description": "The dashboard where the chart will be displayed."}, "options": {"type": "dict", "description": "Additional configuration options for the chart. Default empty dict"}}, "required": ["userData", "scalingFactor", "dashboard"]}, "source_files": ["simple_javascript"]}], "source_files": ["simple_javascript"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "DynamicChartGenerator should be used when the user wants to create or update a chart dynamically and place it into an existing dashboard for visualization. It is appropriate when the user specifies chart characteristics (such as data series or categories, chart type, and axis details), wants the axis values adjusted by a scaling factor, and needs the resulting chart embedded in a particular dashboard or panel. The tool handles three main tasks: generating the chart from provided parameters, applying the scaling factor to axis values, and integrating the finished chart into the specified dashboard location for display. It does not perform generic data analysis, create dashboards from scratch, manage user permissions, or export charts outside the dashboard context. Use this tool instead of static chart or reporting tools whenever the user intent involves dynamically configured charts whose axes must be scaled and then presented inside a designated dashboard view.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:53+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "827e2cf6d21d9665fc79b47d6980951ee360fe08bbd205861742053f78873ca6"}}
{"tool_name": "EFSNIOFile.setContents", "orig_descriptions": [{"description": "Sets the contents of a file with data from the provided InputStream, with options to force the operation and to keep or discard the file history.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"source": {"type": "any", "description": "The InputStream from which file contents are read."}, "force": {"type": "boolean", "description": "If true, the operation is forced, otherwise it's a normal set content operation."}, "keepHistory": {"type": "boolean", "description": "If true, keeps the file history, otherwise discards it."}, "monitor": {"type": "any", "description": "The IProgressMonitor to report progress of the operation."}}, "required": ["source", "force", "keepHistory", "monitor"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to overwrite or create a file’s contents from an existing InputStream source (for example, data already being streamed or read from elsewhere in the system). It replaces the target file’s data with whatever is read from the provided InputStream.\n\nThis tool is specifically for writing from an InputStream, not from raw strings, byte arrays, or other data types. It does not read or return file contents, and it does not create or modify directories.\n\nThe optional “force” behavior controls whether the write proceeds even if there are conflicts or protections, and the history-related option controls whether the previous versions or change history of the file are kept or discarded. Use this tool instead of other file-writing tools whenever the source data is an InputStream and you need explicit control over forcing the write and preserving or discarding file history.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:56+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "32615b7d2a20a7f3210fdccf664e3fdeb2982a29dac615bf694c761418a5b94d"}}
{"tool_name": "EFSNIOResource.copy", "orig_descriptions": [{"description": "Copies the NIO resource to the specified destination path on the filesystem, with an option to force overwrite and a monitor to track progress.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"destination": {"type": "any", "description": "The destination path object where the resource should be copied to. Defined as a Path object that has constructor taking one path parameter"}, "force": {"type": "boolean", "description": "If true, the copy operation will overwrite existing files at the destination."}, "monitor": {"type": "any", "description": "A progress monitor to track the copy operation progress."}}, "required": ["destination", "force", "monitor"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to copy an existing NIO-based resource (the source is defined by the EFSNIOResource instance itself) to a target location on the filesystem. The tool performs a file copy operation from the resource to the given destination path, optionally overwriting any existing file at that path if the force option is enabled. It can also report progress through a provided monitor, which is useful for large files or when you need cancellation or progress tracking behavior tied to the copy operation. This tool does not create or modify the source resource and does not perform directory synchronization, recursive copying of directories, or any transformation of data; it only copies the content as-is to the specified filesystem destination. Choose this tool specifically for copying an EFSNIOResource to a single filesystem path, not for general file management tasks such as deletion, moving, or listing files.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:33:59+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "62594cbe13e23e5cb87ee89905f92224d69bf0bd91e6f4e75749e6d80f95f011"}}
{"tool_name": "Encodings.getEncodingInfo", "orig_descriptions": [{"description": "Retrieves the encoding information for a given encoding name, optionally allowing Java encoding names if the standard IANA name is not found.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"encoding": {"type": "String", "description": "The IANA or Java encoding name."}, "allowJavaNames": {"type": "boolean", "description": "Flag to determine if Java encoding names are allowed."}}, "required": ["encoding", "allowJavaNames"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Gets detailed information about a specific character encoding based on its name. Use this tool when you need to resolve an encoding identifier to its canonical encoding info (for example, to verify that an encoding is supported, to normalize encoding names, or to understand which encoding an input name refers to). The primary lookup is by standard IANA encoding names. If the requested encoding is not found under an IANA name, the tool can optionally consider Java-style encoding names as fallbacks, when that behavior is supported by the environment. This tool does not perform any actual text encoding or decoding, and it does not convert data between encodings. It is only for metadata lookup about encodings from a provided encoding name string. Choose this tool when the user is asking what encoding a name represents or whether a certain encoding is recognized, not when transforming or validating text content.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:02+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "f73b95f92a272470b3366ce2f80ce5f4ad3c339011ec7a114e5e50a61e100157"}}
{"tool_name": "EuclideanDistance.calculate", "orig_descriptions": [{"description": "Calculate the Euclidean distance between two points.", "source_files": ["multiple", "parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"pointA": {"type": "array", "items": {"type": "integer"}, "description": "Coordinates for Point A."}, "pointB": {"type": "array", "items": {"type": "integer"}, "description": "Coordinates for Point B."}, "rounding": {"type": "integer", "description": "Optional: The number of decimals to round off the result. Default 0"}}, "required": ["pointA", "pointB"]}, "source_files": ["multiple"]}, {"parameters": {"type": "dict", "properties": {"pointA": {"type": "array", "items": {"type": "integer"}, "description": "Coordinates for Point A."}, "pointB": {"type": "array", "items": {"type": "integer"}, "description": "Coordinates for Point B."}, "rounding": {"type": "integer", "description": "Optional: The number of decimals to round off the result.", "default": 2}}, "required": ["pointA", "pointB"]}, "source_files": ["parallel_multiple"]}], "source_files": ["multiple", "parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 5, "num_conversations": 2, "num_as_ground_truth": 3, "aug_description": "Use this tool when you need to compute the Euclidean distance (straight-line distance) between two points in a numerical space. It is intended for situations where you already have the coordinates of both points and want a single numeric result representing how far apart they are.\n\nThis tool should be chosen when the user’s question explicitly or implicitly refers to geometric distance, straight-line distance, or Euclidean distance between points. It is not for computing other metrics (such as Manhattan distance, cosine similarity, or edit distance), and it does not perform any clustering, classification, or optimization.\n\nCall this tool only when you can supply complete coordinate information for both points. The output is a single numeric value representing the Euclidean distance; it does not return intermediate steps, vector differences, or any additional geometric properties.\n\nIf the user asks about proximity, nearest neighbors, or measuring how far two coordinate-based items are in a standard geometric sense, prefer this tool over others that measure non-geometric similarity or perform higher-level analysis.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:05+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "68d2398f4f60a2c7ae77906bb64458f37aada76f3241de53931162ab890e86aa"}}
{"tool_name": "EventQuery", "orig_descriptions": [{"description": "Search for calendar events that match a given text query within a user's calendar. The search considers both the title and description of the events.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["search_string"], "properties": {"search_string": {"type": "string", "description": "The text to search for within the title and description of an event."}, "start_date": {"type": "string", "description": "The start date for the range of events to search, in the format 'YYYY-MM-DD'.", "default": "null"}, "end_date": {"type": "string", "description": "The end date for the range of events to search, in the format 'YYYY-MM-DD'.", "default": "null"}, "include_recurring": {"type": "boolean", "description": "A flag to indicate whether to include recurring events in the search.", "default": false}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 2, "aug_description": "Use this tool to search a user’s existing calendar events by free-text content. It should be called when the user asks to find, list, or reference events based on words or phrases, and you need to match against what is written in event titles or descriptions.\n\nThis tool returns events that contain the query text in their title or description. Typical intents include: “Find my meeting about budget,” “Show events mentioning project X,” or “What events talk about onboarding?”\n\nDo not use this tool to create, update, delete, or RSVP to events, or to search by time, date, or attendee alone unless those details are part of the text query itself. For time-based lookups without a textual condition (for example, “What’s on my calendar tomorrow?”), another calendar listing tool should be preferred if available.\n\nAlways provide the user’s query as natural-language text that reflects what they are looking for in event titles or descriptions.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:08+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "e3410caca450af22ecea33fffeb097fae269e165de15c22aa17db42645c7f541"}}
{"tool_name": "EventScheduler", "orig_descriptions": [{"description": "This function schedules a series of events, with each event possibly dependent on the completion of other events. It includes concurrency control to limit the number of simultaneous events.", "source_files": ["simple_javascript"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"events": {"type": "dict", "description": "An object mapping event names to events or arrays that define an event and its prerequisites."}, "concurrencyLimit": {"type": "float", "description": "The maximum number of events that can be scheduled concurrently. Optional parameter. Default 0.0"}, "callback": {"type": "any", "description": "A callback function that is invoked after all events have concluded or if an error has occurred. Optional parameter. Default null"}}, "required": ["events"]}, "source_files": ["simple_javascript"]}], "source_files": ["simple_javascript"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "EventScheduler should be used when the user wants to plan and run multiple events that may depend on one another, while controlling how many can run at the same time. It is intended for scenarios where events form a dependency graph (some must finish before others start) and where concurrent execution needs to be limited to a specific level. The tool arranges the events into an order that respects all dependencies, starts eligible events when their prerequisites are complete, and prevents more than the allowed number of events from running simultaneously. It does not create or define event logic itself; it only coordinates when events are scheduled and allowed to run. It also does not handle external resource provisioning or monitoring beyond enforcing dependencies and concurrency limits. Use this tool instead of simpler scheduling tools when event interdependencies and controlled parallelism are important requirements.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:10+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "bd12d3b2e4356bf55f7440748403040e52826a4d959374bbf9e80c7e231199c0"}}
{"tool_name": "EventSettingsApi.create_mobile_app_alert_config", "orig_descriptions": [{"description": "Creates a configuration for mobile app alerts, allowing users to specify the conditions and types of alerts they wish to receive on their mobile devices.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["user_id", "alert_type", "enabled"], "properties": {"user_id": {"type": "string", "description": "The unique identifier of the user for whom the alert configuration is being created."}, "alert_type": {"type": "string", "description": "The type of alert to configure.", "enum": ["message", "notification", "warning", "alert"]}, "enabled": {"type": "boolean", "description": "A flag indicating whether the alert is enabled or disabled."}, "threshold": {"type": "float", "description": "The numeric threshold that triggers the alert, when applicable.", "default": 0.0}, "sensitivity": {"type": "integer", "description": "The sensitivity level of the alert, represented as an integer from 1 (lowest) to 5 (highest).", "default": 3}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Creates a new configuration for mobile app alerts. Use this tool when the user explicitly wants to set up or customize which alerts they receive on their mobile device and under what conditions. This typically includes choosing alert types (for example, specific event categories or severities), defining when alerts should trigger, and tailoring how alerts behave in the mobile app.\n\nCall this tool to create a fresh mobile alert configuration, not to update or delete an existing one. It should be selected over more general event or notification tools when the focus is specifically on alerts delivered to mobile applications, rather than email, web, or other channels. The tool only defines and saves the configuration; it does not send alerts itself or test them. The configuration it creates will later be used by the alerting system to determine which mobile notifications to deliver to the user based on the specified conditions and types.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:14+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "2a571fd6d6504d7520411def7a18f8e0ad63ec31825a329498730a4fbae5e6b2"}}
{"tool_name": "EventSettingsApi.create_website_alert_config", "orig_descriptions": [{"description": "This API endpoint creates a configuration for website alerts, allowing users to define the conditions under which an alert is triggered and optionally create an associated incident.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["name", "description", "severity", "websiteId"], "properties": {"name": {"type": "string", "description": "The name for the website alert configuration."}, "description": {"type": "string", "description": "A brief description of the website alert configuration."}, "severity": {"type": "integer", "description": "The severity level of the alert when triggered. Can be either 5 for a Warning or 10 for Critical.", "enum": [5, 10]}, "triggering": {"type": "boolean", "description": "A flag indicating whether an Incident is also triggered when the alert is triggered.", "default": false}, "websiteId": {"type": "string", "description": "The unique identifier of the website for which the alert configuration is created."}, "tagFilterExpression": {"type": "string", "description": "A boolean expression of tag filters used to define the scope of relevant website beacons.", "default": ""}, "granularity": {"type": "integer", "description": "The evaluation granularity in minutes, defining the size of the tumbling window used for detection of threshold violations.", "default": 1}, "rule": {"type": "string", "description": "The type of rule this alert configuration represents, such as 'traffic spike' or 'downtime'.", "default": "traffic spike"}, "threshold": {"type": "float", "description": "The value of the threshold this alert rule is evaluated against.", "default": 0.0}, "timeThreshold": {"type": "integer", "description": "The time period in minutes for which the threshold must be violated to trigger the alert.", "default": 5}, "alertChannelIds": {"type": "array", "items": {"type": "string"}, "description": "A list of unique identifiers for alert channels defined in Instana to which the alert notifications will be sent.", "default": []}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to create a new configuration for website alerts, defining when alerts should be triggered for a website or web-based resource. Call this when the user wants to set up or change alerting rules, such as conditions, thresholds, or statuses that determine when an alert fires. This tool can also be used when the user wants an alert to automatically open or associate an incident when its conditions are met.\n\nThis tool only creates a website alert configuration; it does not edit, list, or delete existing configurations, and it does not directly send alerts or modify historical alert data. It should not be used for non-website alert types unless they are explicitly modeled as website alerts in the system. Select this tool when the user’s intent is to define new website alert behavior and optional incident creation logic, not to manage or act on already-triggered alerts or incidents.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:16+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "6187194dd3d08cee8c2bc464ed82348a44ebb9b7419f9439da1fc6444a88f4f8"}}
{"tool_name": "EventSettingsApi.get_alerting_channel", "orig_descriptions": [{"description": "Retrieve the configuration details of a specific alerting channel by its identifier.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["id"], "properties": {"id": {"type": "string", "description": "The unique identifier of the alerting channel."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to fetch the full configuration of a single, existing alerting channel when you already know its identifier. Call it when you need to inspect or display how a specific alerting channel is set up, such as its type, destinations, or other stored settings. This tool is for read-only retrieval of one channel’s details and does not create, update, delete, or list alerting channels. It should be chosen when the user’s intent is to “look up this particular alerting channel by ID” rather than to manage multiple channels or change configurations. If the identifier is invalid or does not correspond to an existing channel, the result may indicate an error or absence of data, depending on the system’s behavior. Do not use this tool to discover available channels, search by name or properties, or modify alerting behavior; it is strictly for configuration lookup by identifier.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:19+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "4ec92236b447f967b09918271967d7039a9e62ee043198f6d1083c16807c90f3"}}
{"tool_name": "EventSettingsApi.get_built_in_event_specifications", "orig_descriptions": [{"description": "Retrieve a list of built-in event specifications using their IDs.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["ids"], "properties": {"ids": {"type": "array", "items": {"type": "string"}, "description": "A list of event specification IDs to retrieve. Each ID is a string uniquely identifying an event specification."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool when you need to look up detailed definitions of specific built-in event specifications by their identifiers. It is intended for cases where you already know one or more built-in event IDs and want to retrieve their corresponding specifications, such as to inspect available fields, types, or constraints for those events.\n\nThis tool only works with built-in event specifications, not custom or user-defined events. It returns information for the requested IDs and does not create, update, or delete any events or specifications. It is a read-only lookup operation.\n\nChoose this tool instead of more general event listing tools when your intent is to fetch specifications for a known subset of built-in events identified by their IDs, rather than browsing or searching all available event types.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:22+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "d1d44930a243809e1374873407798f9c8dbb7181837da3a2e7a33c6fd805616d"}}
{"tool_name": "EventSettingsApi.get_custom_event_specification", "orig_descriptions": [{"description": "Retrieve the specifications for a custom event by its unique identifier.", "source_files": ["live_multiple"]}, {"description": "Retrieve the details of a custom event specification using its unique identifier.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["eventSpecificationId"], "properties": {"eventSpecificationId": {"type": "string", "description": "The unique identifier of the custom event specification."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 0, "aug_description": "Use this tool to retrieve detailed configuration information for a specific custom event when you already know its unique identifier. This is a read-only lookup: it does not create, modify, or delete any events or settings. Call this tool when you need to understand how a custom event is defined (for example, to inspect its structure, metadata, or behavior) before processing, validating, or displaying it elsewhere.\n\nDo not use this tool to search for events by name, type, or other attributes; it requires a unique identifier that directly references the target custom event. If you need to list or discover events without having the identifier, use a different listing or search tool. This tool is appropriate when the user intent is: “Given this custom event ID, tell me exactly how that event is specified.”", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:24+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "72f59c860ea729c51a16bb21bbf4702e6ac662ac4ca6059473dcb01299844c6c"}}
{"tool_name": "EventSettingsApi.get_event_specification_infos_by_ids", "orig_descriptions": [{"description": "Retrieves a summary of all built-in and custom event specifications using their unique identifiers.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["event_ids"], "properties": {"event_ids": {"type": "array", "items": {"type": "string"}, "description": "An array of event specification identifiers to fetch details for."}, "include_details": {"type": "boolean", "description": "Flag to determine whether to include detailed information for each event specification.", "default": false}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to fetch summary information for specific event specifications, both built-in and custom, when you already know their unique identifiers. This is an id-based lookup: you provide one or more event specification IDs, and the tool returns concise information about each matching event specification. It is intended for cases where you are resolving or validating known IDs, displaying event details in a UI, or cross-referencing configuration by ID.\n\nDo not use this tool to search or filter event specifications by name, type, or other attributes when you do not have their IDs; use a search or listing tool instead if available. This tool does not create, update, or delete event specifications, and it does not return full configuration details beyond the defined summary information. Call this tool when the user intent is to retrieve summaries for a known set of event specification IDs and nothing else.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:26+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "ca931c39d66a7f5744bc5fa6e20b66c1a043ded265c510f12f89229fcc543ed6"}}
{"tool_name": "EventSettingsApi.restore_mobile_app_alert_config", "orig_descriptions": [{"description": "Restores the configuration of mobile app alerts to a previous state using the specified ID. This can be used to revert changes or recover a configuration that was mistakenly altered.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["id"], "properties": {"id": {"type": "string", "description": "The unique identifier of the mobile app alert configuration to be restored."}, "created": {"type": "string", "description": "The creation timestamp of the alert configuration in the format 'YYYY-MM-DDTHH:MM:SSZ'.", "default": "null"}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to revert mobile app alert settings to a previously saved configuration identified by an ID. The typical intent is to undo recent changes to alert rules, thresholds, or behaviors and restore an earlier known-good setup. The tool takes an identifier that corresponds to a specific historical configuration and resets the current mobile app alert configuration to match that state.\n\nThis tool does not edit, merge, or partially update alert settings; it performs a full restoration based on the referenced configuration ID. It should not be used to create new configurations or to preview differences between configurations. Choose this tool when a user explicitly requests to roll back or recover prior mobile app alert behavior, especially after an unwanted or erroneous modification.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:29+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "cb0b2a347bb8436720237961bd825bcc6d976ab9e2eef8669f3cea46532e41a6"}}
{"tool_name": "Events_3_BuyEventTickets", "orig_descriptions": [{"description": "Purchase tickets for a specific cultural event on a chosen date in a specified city.", "source_files": ["live_multiple"]}, {"description": "Purchase tickets for a specified cultural event on a certain date in a selected city.", "source_files": ["live_multiple"]}, {"description": "Purchase tickets for a specified cultural event occurring on a particular date in a designated city.", "source_files": ["live_multiple"]}, {"description": "Purchase tickets for a specified cultural event on a given date in a specific city.", "source_files": ["live_multiple"]}, {"description": "Purchase tickets for a specific cultural event on a designated date in a selected city.", "source_files": ["live_multiple"]}, {"description": "Purchase tickets for a specified cultural event on a particular date in a designated city.", "source_files": ["live_multiple"]}, {"description": "Purchase tickets for a specified cultural event on a particular date in a specified city.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Purchase tickets for a specified cultural event occurring on a particular date within a selected city.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Purchase tickets for a specified cultural event on a particular date in a selected city.", "source_files": ["live_multiple"]}, {"description": "Facilitates the purchase of tickets for a cultural event on a specific date in a designated city.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The official title of the event, such as an artist's name or a play title."}, "number_of_tickets": {"type": "integer", "description": "The quantity of tickets to be reserved, must be an integer from 1 to 9.", "enum": [1, 2, 3, 4, 5, 6, 7, 8, 9]}, "date": {"type": "string", "description": "The date of the event, formatted as 'YYYY-MM-DD'."}, "city": {"type": "string", "description": "The name of the city where the event will take place, formatted as 'City, State' (e.g., 'New York, NY')."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The name of the artist or play for which tickets are being purchased."}, "number_of_tickets": {"type": "integer", "description": "The quantity of tickets to reserve for the event."}, "date": {"type": "string", "description": "The scheduled date of the event, in the format 'MM/DD/YYYY'."}, "city": {"type": "string", "description": "The city where the event is being held, in the format 'City, State' (e.g., 'New York, NY')."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The title of the artist's performance or play."}, "number_of_tickets": {"type": "integer", "description": "The quantity of tickets to book for the event. Must be between 1 and 9."}, "date": {"type": "string", "description": "The scheduled date for the event, in the format 'YYYY-MM-DD'."}, "city": {"type": "string", "description": "The locality where the event will be held, in the format of 'City, State' or 'City, Country'. Examples include 'San Francisco, CA' or 'Paris, France'."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The name of the artist or play for which the tickets are being purchased."}, "number_of_tickets": {"type": "integer", "description": "The total number of tickets to be reserved for the event."}, "date": {"type": "string", "description": "The date of the event, in the format 'MM/DD/YYYY'."}, "city": {"type": "string", "description": "The city where the event will take place, in the format of 'City, State', such as 'Berkeley, CA' or 'New York, NY'."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The title of the cultural event, such as a concert, play, or exhibition."}, "number_of_tickets": {"type": "integer", "description": "The quantity of tickets to be purchased for the event."}, "date": {"type": "string", "description": "The scheduled date of the event, in the format 'YYYY-MM-DD'."}, "city": {"type": "string", "description": "The city in which the event will take place, formatted as 'City, State' or 'City, Country', such as 'New York, NY' or 'London, UK'."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The exact title of the artist's performance or play for which tickets are being purchased."}, "number_of_tickets": {"type": "integer", "description": "The quantity of tickets to book for the event."}, "date": {"type": "string", "description": "The scheduled date of the event, in the format 'MM/DD/YYYY'."}, "city": {"type": "string", "description": "The city where the event will take place, formatted as 'City, State', such as 'Los Angeles, CA' or 'New York, NY'."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The name of the artist or the play for which tickets are being purchased."}, "number_of_tickets": {"type": "integer", "description": "The total number of tickets to be reserved for the event.", "enum": [1, 2, 3, 4, 5, 6, 7, 8, 9]}, "date": {"type": "string", "description": "The date of the event, in the format 'YYYY-MM-DD'."}, "city": {"type": "string", "description": "The city where the event is located, expected in the format of 'City, State', such as 'New York, NY'."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The name of the artist or play for which tickets are being purchased."}, "number_of_tickets": {"type": "integer", "description": "The quantity of tickets to be reserved for the event."}, "date": {"type": "string", "description": "The date of the event, in the format 'YYYY-MM-DD'."}, "city": {"type": "string", "description": "The city where the event will take place, in the format of 'City, State', such as 'Berkeley, CA' or 'New York, NY'."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The name of the artist or play for which the tickets are being purchased."}, "number_of_tickets": {"type": "integer", "description": "The quantity of tickets to be reserved, ranging from 1 to 9."}, "date": {"type": "string", "description": "The scheduled date of the event, in the format 'MM/DD/YYYY'."}, "city": {"type": "string", "description": "The city where the event is being held, in the format of 'City, State', such as 'Berkeley, CA' or 'New York, NY'."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The name of the artist, play, or cultural event."}, "number_of_tickets": {"type": "integer", "description": "The quantity of tickets to purchase. Must be a positive integer and typically ranges from 1 to 8."}, "date": {"type": "string", "description": "The specific date of the event, in the format 'YYYY-MM-DD'."}, "city": {"type": "string", "description": "The city where the event will take place, formatted as 'City, State' or 'City, Country' if the city does not locate in the United States, such as 'New York, NY' or 'London, UK'."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date"], "properties": {"event_name": {"type": "string", "description": "The name of the artist or the title of the play for which tickets are being purchased."}, "number_of_tickets": {"type": "integer", "description": "The quantity of tickets to be reserved for the event."}, "date": {"type": "string", "description": "The scheduled date of the event, in the format 'YYYY-MM-DD'."}, "city": {"type": "string", "description": "The city where the event is located, in the format of 'City, State', such as 'Berkeley, CA' and 'New York, NY'.", "default": ""}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The name of the artist or the play for which tickets are being purchased."}, "number_of_tickets": {"type": "integer", "description": "The total number of tickets to be reserved for the event.", "enum": [1, 2, 3, 4, 5, 6, 7, 8, 9]}, "date": {"type": "string", "description": "The date of the event, in the format 'YYYY-MM-DD'."}, "city": {"type": "string", "description": "The city where the event is located, expected in the format of 'City, State (abbr)', such as 'New York, NY'."}}}, "source_files": ["live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["event_name", "number_of_tickets", "date", "city"], "properties": {"event_name": {"type": "string", "description": "The name of the artist or play for which the tickets are being purchased."}, "number_of_tickets": {"type": "integer", "description": "The quantity of tickets to be reserved, ranging from 1 to 9."}, "date": {"type": "string", "description": "The scheduled date of the event, in the format 'MM/DD/YYYY'."}, "city": {"type": "string", "description": "The city where the event is being held, in the format of 'City, State (abbr)', such as 'Berkeley, CA' or 'New York, NY'."}}}, "source_files": ["live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 135, "num_conversations": 132, "num_as_ground_truth": 3, "aug_description": "Use this tool when the user explicitly wants to buy tickets for a cultural event (such as a concert, theater performance, exhibition, or similar) on a particular date in a specific city. The core intent should be completing a ticket purchase, not just browsing, comparing, or asking for recommendations.\n\nThis tool expects that the user has already chosen an event (or clearly described it), the city where it takes place, and the desired date. If any of these are missing or ambiguous, first ask the user to clarify before invoking the tool.\n\nDo not use this tool for non-cultural events (e.g., flights, sports matches, conferences) unless the broader system defines them as cultural events. Do not use it to check availability, prices, or schedules without an expressed intent to proceed to purchase. If the user is only exploring options, another search or recommendation tool is more appropriate.\n\nThe output should correspond to executing a ticket purchase flow for the specified cultural event, date, and city.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:32+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "1eb7f795da7cc17faa7cdbb4624e6076b5e663d12c6c2324ddca2f52b05027ff"}}
{"tool_name": "Events_3_FindEvents", "orig_descriptions": [{"description": "Find cultural events, such as concerts and plays, happening in a specified city on a given date.", "source_files": ["live_multiple"]}, {"description": "Find cultural events, including concerts and plays, happening in a specified city on a given date.", "source_files": ["live_multiple"]}, {"description": "Searches for cultural events, including concerts and plays, that are scheduled to occur in a specified city.", "source_files": ["live_multiple"]}, {"description": "Find cultural events, such as concerts and plays, happening in a specified city on a particular date.", "source_files": ["live_multiple"]}, {"description": "Find cultural events such as concerts and plays happening in a specified city on a particular date or any upcoming date if the date is unspecified.", "source_files": ["live_multiple"]}, {"description": "Finds and lists cultural events, such as concerts and plays, that are scheduled to occur in a specified city.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Find cultural events, such as concerts and plays, happening in a specified city. The search can be filtered by event type and date.", "source_files": ["live_multiple"]}, {"description": "Retrieves a list of cultural events such as concerts and plays happening in a specified city on a given date.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Finds cultural events, such as concerts and plays, happening in a specified city on a given date.", "source_files": ["live_multiple"]}, {"description": "Find cultural events, such as concerts and plays, happening in a specified city and optionally on a specific date.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to find. Events include concerts and plays.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city where the event is taking place, in the format 'City, State' or 'City, Country' (e.g., 'New York, NY' or 'London, UK'). State names must be abbreviated with two letters."}, "date": {"type": "string", "description": "The date of the event. Use the format 'YYYY-MM-DD'. If not specified, the current date is used.", "default": null}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to find. Events include concerts and plays. State names must be abbreviated with two letters.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city where the event is taking place, in the format 'City, State' or 'City, Country' (e.g., 'New York, NY' or 'London, UK')."}, "date": {"type": "string", "description": "The date of the event. Use the format 'YYYY-MM-DD'. If not specified, the current date is used.", "default": null}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to find. Events include concerts and plays.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city where the event is taking place, in the format 'City, State' or 'City, Country' (e.g., 'New York, NY' or 'London, UK'). State names should be abbreviated (e.g., 'CA' for California)."}, "date": {"type": "string", "description": "The date of the event. Use the format 'YYYY-MM-DD'. If not specified, the current date is used.", "default": null}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to find. Events include concerts and plays.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city where the event is taking place, in the format 'City, State' or 'City, Country' (e.g., 'New York, NY' or 'London, UK'). State names should be abbreviated (e.g., 'CA' for California)"}, "date": {"type": "string", "description": "The date of the event. Use the format 'YYYY-MM-DD'. If not specified, the current date is used.", "default": null}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to find. Events include concerts and plays.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city where the event is taking place, in the format 'City, State' or 'City, Country' (e.g., 'New York, NY' or 'London, UK')."}, "date": {"type": "string", "description": "The date of the event. Use the format 'YYYY-MM-DD'. If not specified, the current date is used.", "default": null}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to search for.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city in which to search for events, formatted as 'City, State' (e.g., 'New York, NY')."}, "date": {"type": "string", "description": "The date of the event, formatted as 'MM/DD/YYYY'. If not specified, the function will search for all upcoming events.", "default": "current date"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The category of the cultural event.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The name of the city where the event is taking place, formatted as 'City, State' or 'City, Country', e.g., 'New York, NY' or 'London, UK'."}, "date": {"type": "string", "description": "The date on which the event is happening, formatted as 'YYYY-MM-DD'. If the date is not provided, the current date is assumed.", "default": "current_date"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to find.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city where the event is taking place, in the format of 'City, State', such as 'Berkeley, CA' or 'New York, NY'. State names must be abbreviated"}, "date": {"type": "string", "description": "The date of the event in the format 'YYYY-MM-DD'. If not specified, the current date is assumed.", "default": "null"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to find.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city where the event is taking place, in the format of 'City, State', such as 'Berkeley, CA' or 'New York, NY'. State name must be abbreviated"}, "date": {"type": "string", "description": "The date of the event in the format 'YYYY-MM-DD'. If not specified, the current date is assumed.", "default": "null"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The category of cultural event to find.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city where the event is being searched for, in the format of 'City, State' (e.g., 'San Francisco, CA'). State names must be abbreviated"}, "date": {"type": "string", "description": "The date of the event, formatted as 'MM/DD/YYYY'. If not specified, the search will include events for all upcoming dates.", "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The category of cultural event to find.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city where the event is being searched for, in the format of 'City, State' (e.g., 'San Francisco, CA')."}, "date": {"type": "string", "description": "The date of the event, formatted as 'MM/DD/YYYY'. If not specified, the search will include events for all upcoming dates.", "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The category of the cultural event to find.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city in which the search for events is to be conducted, in the format of 'City, State' (e.g., 'San Francisco, CA')."}, "date": {"type": "string", "description": "The date for which to find events, formatted as 'MM/DD/YYYY'. If left as 'dontcare', the search will include all upcoming events.", "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The category of the cultural event.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The name of the city where the event is happening, formatted as 'City, State' or 'City' if the city does not have a state. For example, 'New York, NY' or 'Paris'."}, "date": {"type": "string", "description": "The date of the event, formatted as 'YYYY-MM-DD'. If not specified, any date is considered.", "default": "any"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The category of the cultural event.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The name of the city where the event is happening, formatted as 'City, State' or 'City', if it is in the US. For example, 'New York, NY' or 'Paris'."}, "date": {"type": "string", "description": "The date of the event, formatted as 'YYYY-MM-DD'. If not specified, any date is considered.", "default": "any"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The category of the cultural event.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The name of the city where the event is happening, formatted as 'City, State' or 'City' if the city doesn't belong to a state. For example, 'New York, NY' or 'Paris'."}, "date": {"type": "string", "description": "The date of the event, formatted as 'YYYY-MM-DD'. If not specified, any date is considered.", "default": "any"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to find.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city in which to search for events, in the format of 'City, State' (e.g., 'New York, NY')."}, "date": {"type": "string", "description": "The date for which to find events, formatted as 'YYYY-MM-DD'. If set to 'dontcare', any date is considered.", "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The category of the cultural event to find.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The name of the city where the event is taking place, in the format of 'City, State', such as 'New York, NY' or 'Los Angeles, CA'."}, "date": {"type": "string", "description": "The date of the event in the format 'YYYY-MM-DD'. If 'dontcare' is specified, any date will be considered. The default value 'dontcare' represents no specific date preference.", "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to find.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city in which to search for events, in the format of 'City, State', such as 'Berkeley, CA' and 'New York, NY'."}, "date": {"type": "string", "description": "The date of the event, formatted as 'MM/DD/YYYY'. If not specified, the search will include events for all upcoming dates.", "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to find. Possible values are 'Music' for concerts and 'Theater' for plays.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city where the event is taking place, in the format of 'City, State' (e.g., 'New York, NY')."}, "date": {"type": "string", "description": "The date of the event in the format 'YYYY-MM-DD'. If not specified, the function will search for events regardless of date.", "default": null}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The type of cultural event to find. Possible values are 'Music' for concerts and 'Theater' for plays.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The city where the event is taking place, in the format of 'City, State', with state using the abbreviated name (e.g., 'New York, NY')."}, "date": {"type": "string", "description": "The date of the event in the format 'YYYY-MM-DD'. If not specified, the function will search for events regardless of date.", "default": null}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The category of the cultural event.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The name of the city where the event is happening, formatted as 'City, State (abbr)' or 'City' if state not available. For example, 'New York, NY' or 'Paris'. If using the state then use only short forms."}, "date": {"type": "string", "description": "The date of the event, formatted as 'YYYY-MM-DD'. If not specified, any date is considered.", "default": "any"}}}, "source_files": ["live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The category of the cultural event.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The name of the city where the event is happening, formatted as 'City, State (abbr)' or 'City'. For example, 'New York, NY' or 'Paris'. Use short form for the state."}, "date": {"type": "string", "description": "The date of the event, formatted as 'YYYY-MM-DD'. If not specified, any date is considered.", "default": "any"}}}, "source_files": ["live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["event_type", "city"], "properties": {"event_type": {"type": "string", "description": "The category of the cultural event to find.", "enum": ["Music", "Theater"]}, "city": {"type": "string", "description": "The name of the city where the event is taking place, in the format of 'City, State (abbr)', such as 'New York, NY' or 'Los Angeles, CA'. Use short form for state"}, "date": {"type": "string", "description": "The date of the event in the format 'YYYY-MM-DD'. If 'dontcare' is specified, any date will be considered. The default value 'dontcare' represents no specific date preference.", "default": "dontcare"}}}, "source_files": ["live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 135, "num_conversations": 132, "num_as_ground_truth": 89, "aug_description": "Use this tool when the user wants to discover cultural events scheduled in a specific city on a specific date. It is intended for queries about time-bound, in-person or local cultural activities such as concerts, theater performances, plays, and similar events.\n\nThis tool should be called when the user provides (or clearly implies) both a city and a date or date range and wants a list of relevant cultural events, possibly to plan an outing, trip, or evening activity. It focuses on events that happen at a particular place and time, not on general tourist attractions, museums, or permanent points of interest.\n\nDo not use this tool for booking tickets, purchasing anything, or getting venue logistics beyond what is included with the event listing. Do not use it for online-only events, general city information, restaurant recommendations, or transportation planning. Prefer this tool over general search or recommendation tools when the key need is “What cultural events are happening in city X on date Y?”.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:36+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "e05f168efa504b8cda4b546c8f0ef938115bb4c55cdaf37c4dd64059bf754fd0"}}
{"tool_name": "ExasolExecutionContext.setCurrentSchema", "orig_descriptions": [{"description": "Sets the current schema for the Exasol execution context to the specified schema name, and monitors the progress of this operation.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"monitor": {"type": "any", "description": "The progress monitor to track the execution of setting the current schema."}, "schemaName": {"type": "String", "description": "The name of the schema to set as the current schema."}}, "required": ["monitor", "schemaName"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Sets the current schema for the Exasol execution context to a given schema name and tracks the progress of that change. Use this tool when you need subsequent Exasol operations (such as queries or DDL/DML statements executed in the same context) to run against a specific schema without having to fully qualify object names.\n\nThis tool should be chosen when the user’s intent is to switch the active schema within an already established Exasol execution context. It does not create, modify, or delete schemas, and it does not execute arbitrary SQL or manage connections. It assumes a valid connection and context already exist.\n\nThe tool focuses only on changing the active schema and monitoring that operation’s completion or status. If you need to perform other database actions (for example, running queries, managing tables, or changing connections), use the appropriate dedicated tools instead.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:39+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "b5670b900da9d7dab01c3b06a9e962009d685f11fb9dd998afcbe96210fd319f"}}
{"tool_name": "ExportNodeTest.doGeneric", "orig_descriptions": [{"description": "Executes a generic operation on the given receiver object with the provided argument, using a specialized inlinable node and bound to a node library.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"receiver": {"type": "any", "description": "The receiver object on which the operation is performed."}, "argument": {"type": "String", "description": "The argument to pass to the node's execute method."}, "node": {"type": "any", "description": "The specialized inlinable node used for execution."}, "library": {"type": "any", "description": "The node library to which this operation is bound."}}, "required": ["receiver", "argument", "node", "library"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Executes a generic operation on a given receiver object with a single argument, using an inlinable node that is bound to a node library.\n\nUse this tool when you need to conceptually “invoke” or “apply” an operation represented by a node on a receiver with one argument, but you do not care about the specific operation name or method details. The intent is to model a generic dispatch or computation step where the logic is encapsulated by the node and its library binding.\n\nDo not use this tool to construct or configure nodes, to manage node libraries, or to perform multiple operations or batch processing. It is not for introspection, reflection, or querying metadata about the operation or the receiver.\n\nChoose this tool when the user request boils down to: given an existing, already-configured operation node, apply it to this receiver and argument, and return the result of that single generic operation.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:41+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "2219eb7b898c3d2578085635093b2e759f5e99898449837d98c4bdbe576f0be5"}}
{"tool_name": "FireBirdUtils.getViewSourceWithHeader", "orig_descriptions": [{"description": "Generates the SQL script to create or alter a Firebird database view, including the view definition header, based on the server version and the provided source.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"monitor": {"type": "any", "description": "The DBRProgressMonitor to monitor the progress of the operation."}, "view": {"type": "any", "description": "The GenericTableBase object representing the view."}, "source": {"type": "String", "description": "The SQL source code of the view."}}, "required": ["monitor", "view", "source"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Generates a complete SQL script for creating or altering a Firebird database view, including the appropriate header section for the specific server version and the provided view source text. Use this tool when you already have the body/definition of a Firebird view and need a correctly structured CREATE OR ALTER VIEW statement that is compatible with a given Firebird server version. This tool focuses only on producing the DDL script for a single view; it does not execute the script, validate the SQL against a live database, manage dependencies, or handle other database objects (tables, triggers, procedures, etc.). Choose this tool when the user’s intent is to obtain or regenerate the textual SQL definition of a Firebird view, especially when compatibility with different Firebird versions affects the required header syntax.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:44+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "5a75eb4ed62a5771f2ec3c9c968f66f8d2d1031f3d7853cb43d9cabfbe556a14"}}
{"tool_name": "FlatNodeGenFactory.generateIntrospectionInfo", "orig_descriptions": [{"description": "Generates introspection information for a given class representing a node in the Truffle DSL processor.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"clazz": {"type": "any", "description": "The class element representing the node for which introspection information is to be generated."}, "inlined": {"type": "boolean", "description": "Indicates whether the introspection is inlined."}}, "required": ["clazz", "inlined"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to obtain structured introspection information for a single class that represents a node in the Truffle DSL processor. The input must be a class that conforms to the Truffle node conventions; the tool then analyzes that class and produces metadata describing it (for example, information suitable for tooling, analysis, or reflection within the Truffle DSL context).\n\nThis tool does not modify the class, generate source code, or execute any node logic. It only inspects the given node class and returns information about it. Do not use this tool for non-node classes or for general Java reflection outside the Truffle DSL domain. Choose this tool over others when your intent is specifically to introspect a Truffle DSL node class and retrieve its descriptive metadata for further processing or integration.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:47+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "bd5be5d5050937e9c54ec6be0126db6bb8b453410bddaccad261cb814dd096a7"}}
{"tool_name": "Flights_4_SearchOnewayFlight", "orig_descriptions": [{"description": "Search for one-way flights from an origin to a destination on a specified date, with options for seating class, ticket quantity, and preferred airline.", "source_files": ["live_multiple"]}, {"description": "Search for one-way flights to the destination, allowing users to select various options such as departure date, seating class, and preferred airlines.", "source_files": ["live_multiple"]}, {"description": "Search for one-way flights from an origin to a specified destination on a particular date. This function allows filtering by seating class, the number of tickets, and preferred airlines.", "source_files": ["live_multiple"]}, {"description": "Search for one-way flights from an origin to a destination on a specific date, with options for seating class and preferred airlines.", "source_files": ["live_multiple"]}, {"description": "Search for one-way flights from an origin to a destination on a specified date, with options for seating class and preferred airlines.", "source_files": ["live_multiple"]}, {"description": "Search for one-way flights from a specified origin airport to a destination airport on a given departure date. Options for seating class and preferred airlines can be specified.", "source_files": ["live_multiple", "live_parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA code or the name of the airport or city to depart from. For example, 'LAX' for Los Angeles International Airport."}, "destination_airport": {"type": "string", "description": "The IATA code or the name of the airport or city to arrive at. For example, 'JFK' for John F. Kennedy International Airport."}, "departure_date": {"type": "string", "description": "The start date of the trip in the format 'YYYY-MM-DD'."}, "seating_class": {"type": "string", "description": "The cabin seat option for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets for the trip.", "default": 1}, "airlines": {"type": "string", "description": "The preferred airline company for the flight. Use 'dontcare' if there is no preference.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA code or name of the airport or city to depart from, such as 'SFO' for San Francisco International Airport."}, "destination_airport": {"type": "string", "description": "The IATA code or name of the airport or city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The start date of the trip in the format 'YYYY-MM-DD', e.g., '2023-07-15'."}, "seating_class": {"type": "string", "description": "The cabin seating class option for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "The preferred airline company for air transport services. Use 'dontcare' to indicate no preference.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA code or the name of the airport or city to depart from. For example, 'SFO' for San Francisco."}, "destination_airport": {"type": "string", "description": "The IATA code or the name of the airport or city to arrive at. For example, 'LAX' for Los Angeles."}, "departure_date": {"type": "string", "description": "The departure date for the flight in the format 'YYYY-MM-DD'. For example, '2023-04-15'."}, "seating_class": {"type": "string", "description": "The class of the cabin seat.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "The preferred airline for the flight. Use 'dontcare' for no preference.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA code or the name of the airport or city to depart from."}, "destination_airport": {"type": "string", "description": "The IATA code or the name of the airport or city to arrive at."}, "departure_date": {"type": "string", "description": "The start date of the trip in the format of 'YYYY-MM-DD'."}, "seating_class": {"type": "string", "description": "The cabin seat class for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. Use 'dontcare' for no preference.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA code or the name of the airport to depart from."}, "destination_airport": {"type": "string", "description": "The IATA code or the name of the airport to arrive at."}, "departure_date": {"type": "string", "description": "The start date of the trip in the format of 'YYYY-MM-DD'."}, "seating_class": {"type": "string", "description": "The cabin seat class for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. Use 'dontcare' for no preference.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code to depart from, such as 'JFK' for John F. Kennedy International Airport"}, "destination_airport": {"type": "string", "description": "The IATA airport code to arrive at, such as 'LAX' for Los Angeles International Airport"}, "departure_date": {"type": "string", "description": "The start date of the trip in the format 'YYYY-MM-DD', such as '2023-04-15'."}, "seating_class": {"type": "string", "description": "The cabin class option for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip."}, "airlines": {"type": "string", "description": "The preferred airline for the flight. Use 'dontcare' to include all available airlines.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or the name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport or 'New York'. "}, "destination_airport": {"type": "string", "description": "The IATA airport code or the name of the city to arrive at, such as 'LAX' for Los Angeles International Airport or 'Los Angeles'."}, "departure_date": {"type": "string", "description": "The start date of the trip in the format 'YYYY-MM-DD', such as '2023-04-15'."}, "seating_class": {"type": "string", "description": "The cabin class option for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "The preferred airline for the flight. Use 'dontcare' to include all available airlines.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or the name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport or 'New York'."}, "destination_airport": {"type": "string", "description": "The IATA airport code or the name of the city to arrive at, such as 'LAX' for Los Angeles International Airport or 'Los Angeles'."}, "departure_date": {"type": "string", "description": "The start date of the trip in the format 'YYYY-MM-DD', such as '2023-04-15'."}, "seating_class": {"type": "string", "description": "The cabin class option for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "The preferred airline for the flight. Use 'dontcare' to include all available airlines.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code depart from, such as 'JFK' for John F. Kennedy International Airport"}, "destination_airport": {"type": "string", "description": "The IATA airport code to arrive at, such as 'LAX' for Los Angeles International Airport"}, "departure_date": {"type": "string", "description": "The start date of the trip in the format 'YYYY-MM-DD', such as '2023-04-15'."}, "seating_class": {"type": "string", "description": "The cabin class option for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "The preferred airline for the flight. Use 'dontcare' to include all available airlines.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA code or the name of the airport or city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA code or the name of the airport or city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The start date of the trip in the format of 'YYYY-MM-DD', for example '2023-07-15'."}, "seating_class": {"type": "string", "description": "The cabin seat option for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "The preferred airline company for the flight. Select 'dontcare' if no preference.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 83, "num_conversations": 82, "num_as_ground_truth": 10, "aug_description": "Use this tool to search for one-way commercial flights when the user specifies a single departure date and wants to travel from one origin to one destination without a return segment. It finds available flights that match requested parameters such as seating class, number of tickets, and preferred airline. This tool is appropriate when the user is planning a one-way trip, comparing options for a specific departure date, or checking availability and pricing for a single-leg journey.\n\nDo not use this tool for round-trip, multi-city, or open-jaw itineraries, or when the user needs to modify, cancel, or manage existing bookings. It does not handle hotels, cars, or other travel services. It is only for searching, not booking; if booking is required, another tool must be used after the user chooses an option.\n\nTrigger this tool when the user explicitly asks for one-way flight options, schedules, or prices between two places on a given date, possibly with preferences for cabin class, number of passengers, or specific airlines.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:50+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "6afc27edfa08e3175133a7df4b7773acd2a4a14323a5888a6694b0a34885b374"}}
{"tool_name": "Flights_4_SearchRoundtripFlights", "orig_descriptions": [{"description": "Search for roundtrip flights based on specified criteria including departure and return dates, airports, seating class, and airlines.", "source_files": ["live_multiple"]}, {"description": "Search for roundtrip flights based on the specified criteria, including departure and return dates, airports, seating class, and more.", "source_files": ["live_multiple"]}, {"description": "Search for roundtrip flights between two airports on specified dates, with options for seating class and preferred airlines.", "source_files": ["live_multiple"]}, {"description": "Search for roundtrip flights based on origin, destination, dates, seating class, and other preferences.", "source_files": ["live_multiple"]}, {"description": "Search for available roundtrip flights based on specific criteria such as airports, dates, seating class, and airline preference.", "source_files": ["live_multiple"]}, {"description": "Search for roundtrip flights based on specified criteria, including departure and return dates, airports, seating class, number of tickets, and preferred airlines.", "source_files": ["live_multiple", "live_parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date", "return_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or the name of the city for the departure airport. Example: 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or the name of the city for the arrival airport. Example: 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip, in the format 'YYYY-MM-DD'."}, "return_date": {"type": "string", "description": "The return date for the trip, in the format 'YYYY-MM-DD'."}, "seating_class": {"type": "string", "description": "The class of the cabin seat.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the trip. Use 'dontcare' to include all available airlines.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date", "return_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA code or name of the originating airport or city, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA code or name of the destination airport or city, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The start date of the trip in the format 'YYYY-MM-DD'."}, "return_date": {"type": "string", "description": "The end date of the trip in the format 'YYYY-MM-DD'."}, "seating_class": {"type": "string", "description": "The cabin seat option for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The total number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "The preferred airline company for the trip. Use 'dontcare' if there is no preference.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date", "return_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or city name to depart from, such as 'JFK' for John F. Kennedy International Airport or 'New York'."}, "destination_airport": {"type": "string", "description": "The IATA airport code or city name to arrive at, such as 'LAX' for Los Angeles International Airport or 'Los Angeles'."}, "departure_date": {"type": "string", "description": "The departure date for the outbound flight, in the format 'YYYY-MM-DD', such as '2023-07-15'."}, "return_date": {"type": "string", "description": "The return date for the inbound flight, in the format 'YYYY-MM-DD', such as '2023-07-22'."}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The total number of tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "The preferred airline for the trip. Use 'dontcare' if there is no preference.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": "null"}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'.", "default": "null"}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport or 'Chicago'"}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport or 'Chicago'"}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": "null"}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'. If not specified, it defaults to null which represents an open return date.", "default": "null"}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": "null"}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'.", "default": "null"}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'. If not specified, it defaults to null, which represents no specific return date.", "default": null}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'. If not specified, defaults to null representing no specific return date.", "default": null}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'. If not specified, it defaults to 7 days after the departure date.", "default": null}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'. If no date is specified, the default is to search for flights departing today.", "default": null}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'. If no date is specified, the default is to search for flights returning seven days from today.", "default": null}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": "null"}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'. If not specified, defaults to null, which represents no return date set.", "default": "null"}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport or 'Chicago'."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport or 'Chicago'."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'. If not specified, it is assumed to be 7 days after the departure date.", "default": null}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'. If not specified, it assumes a one-way trip.", "default": null}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'. The default value represents the current date.", "default": null}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'. If not specified, defaults to 7 days after the departure date.", "default": null}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or name of the city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or name of the city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'. If not specified, the system will consider it as a one-way trip.", "default": null}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "return_date": {"type": "string", "description": "The return date for the trip in the format 'YYYY-MM-DD'.", "default": null}, "seating_class": {"type": "string", "description": "The class of the cabin seat for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the flight. If no preference, 'dontcare' can be specified.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date", "return_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA airport code or city name where the trip will begin. For example, 'LAX' for Los Angeles International Airport."}, "destination_airport": {"type": "string", "description": "The IATA airport code or city name of the intended destination. For example, 'JFK' for John F. Kennedy International Airport."}, "departure_date": {"type": "string", "description": "The departure date for the outbound flight, in the format 'YYYY-MM-DD'."}, "return_date": {"type": "string", "description": "The return date for the inbound flight, in the format 'YYYY-MM-DD'."}, "seating_class": {"type": "string", "description": "The class of service for seating on the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The total number of tickets to book for the trip.", "default": 1}, "airlines": {"type": "string", "description": "Preferred airline for the trip. Select 'dontcare' if no preference.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["origin_airport", "destination_airport", "departure_date", "return_date"], "properties": {"origin_airport": {"type": "string", "description": "The IATA code or name of the airport or city to depart from, such as 'JFK' for John F. Kennedy International Airport."}, "destination_airport": {"type": "string", "description": "The IATA code or name of the airport or city to arrive at, such as 'LAX' for Los Angeles International Airport."}, "departure_date": {"type": "string", "description": "The start date of the trip, in the format 'YYYY-MM-DD'."}, "return_date": {"type": "string", "description": "The end date of the trip, in the format 'YYYY-MM-DD'."}, "seating_class": {"type": "string", "description": "The cabin seat option for the flight.", "enum": ["Economy", "Premium Economy", "Business"], "default": "Economy"}, "number_of_tickets": {"type": "integer", "description": "The number of flight tickets required for the trip.", "default": 1}, "airlines": {"type": "string", "description": "The preferred airline for the trip. Use 'dontcare' if there is no preference.", "enum": ["United Airlines", "American Airlines", "Delta Airlines", "Southwest Airlines", "Alaska Airlines", "British Airways", "Air Canada", "Air France", "South African Airways", "LOT Polish Airlines", "LATAM Brasil", "dontcare"], "default": "dontcare"}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 83, "num_conversations": 82, "num_as_ground_truth": 4, "aug_description": "Use this tool to search for roundtrip flights when the user specifies both an outbound (departure) date and a return date, along with desired airports and other preferences. It is intended for cases where the traveler will depart from one location, go to another, and then come back, all within a single search. This tool focuses on finding flight options that match criteria such as departure and arrival airports, travel dates, seating class, and preferred airlines, and returns a set of suitable roundtrip itineraries. Do not use this tool for one-way flights, multi-city or open-jaw itineraries, or for tasks like booking, modifying, or canceling existing reservations. Choose this tool when the user’s main intent is to compare or discover roundtrip flight options that fit given constraints, not to handle payments, tickets, or non-flight travel such as trains or hotels.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:52+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "5e25cd0ae1349e909d89758ed1f1d29794a327a020bacb73d964b93dabb5587e"}}
{"tool_name": "FunGameBase.onFinish", "orig_descriptions": [{"description": "Handles the finish event of the FunGame refresh header, updating the last finish status and handling manual operations if necessary.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"layout": {"type": "any", "description": "The RefreshLayout instance associated with the FunGame refresh header."}, "success": {"type": "boolean", "description": "Indicates whether the refresh operation was successful."}}, "required": ["layout", "success"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Handles the completion event of the FunGame refresh header. Use this tool when a refresh (pull-to-refresh or similar interaction) has just finished and you need to update the internal \"last finish\" state for the game-like header component. It is intended to be called after the refresh operation (such as data loading) is done, not to start or control the refresh itself. This tool focuses only on post-finish behavior: recording that the finish occurred and performing any required manual follow-up actions tied to the end of the refresh animation or logic. It does not load data, trigger the refresh, configure the header, or manage other UI components. Choose this tool when you must signal that the FunGame header’s refresh cycle is complete so that its state, visuals, or related manual operations can be finalized correctly.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:55+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "8c23eea74240cbd973acedade766ff2ef6182628e2ce02132eef1d924699723c"}}
{"tool_name": "GET_PARCEL_STATE", "orig_descriptions": [{"description": "Determines the current state of the parcel, such as 'In Transit', 'Delivered', or 'Awaiting Pickup', based on the provided tracking ID.", "source_files": ["live_multiple"]}, {"description": "Retrieves the current state of a parcel using its tracking ID.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["parcelTrackingId"], "properties": {"parcelTrackingId": {"type": "string", "description": "Unique identifier for the parcel used to track its movement and status."}, "includeHistory": {"type": "boolean", "description": "Determines if the historical states of the parcel should be included in the response.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["parcelTrackingId"], "properties": {"parcelTrackingId": {"type": "string", "description": "The unique identifier for tracking the parcel."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 1, "aug_description": "Use this tool when the user wants to know the current delivery status of a parcel from its tracking ID. The tool returns a high-level state such as “In Transit”, “Delivered”, or “Awaiting Pickup”, depending on what is recorded for that tracking ID. It is intended for status lookup only, not for changing, canceling, or rerouting shipments, and not for finding tracking IDs. The user must already provide a valid tracking ID; if none is available or the ID is clearly missing, do not call this tool. Prefer this tool over others when the question is specifically “Where is my parcel now?”, “Has my package been delivered?”, or “Is my shipment ready for pickup?” and only a concise status value is needed, without detailed tracking history, timestamps, or location breakdowns.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:34:57+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "569615fda2c5d593e8372b88fc3a332125f2e963aef04c551e39d939b8c84bb3"}}
{"tool_name": "GameGuideAPI.search_guide", "orig_descriptions": [{"description": "Search for game guides given specific conditions and preferences", "source_files": ["parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"game": {"type": "string", "description": "Name of the game."}, "condition": {"type": "string", "description": "Specific game conditions. (eg: 'snowy weather', 'hard mode').", "default": ""}, "type": {"type": "string", "description": "Specific type of guide. (eg: 'strategy', 'walkthrough')", "default": ""}}, "required": ["game"]}, "source_files": ["parallel_multiple"]}], "source_files": ["parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 3, "num_conversations": 1, "num_as_ground_truth": 2, "aug_description": "Use this tool when a user wants to find game guides that match specific conditions or preferences. Typical intents include: locating walkthroughs, strategy guides, build guides, quest help, boss tactics, or optimization tips for a particular game or game mode, filtered by criteria such as topic focus, difficulty level, progression stage, or other stated preferences.\n\nThis tool searches an existing collection of game guides and returns only information about guides that match the search conditions. It does not play games, simulate gameplay, generate entirely new guides from scratch, or modify game data. It also does not manage user accounts, track achievements, or change in-game settings.\n\nChoose this tool over more general search or recommendation tools when the request is clearly about structured guidance for playing a game (e.g., “find a detailed guide for early-game leveling in X,” “show a build guide for character Y,” “find a guide focused on endgame raids”). If the user asks for factual game info unrelated to guides (such as lore or system requirements), do not use this tool.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:00+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "584c66222d87d24a86c76f786e44f7982cd17cc6dd48e5f10b529565369e551b"}}
{"tool_name": "GenericTypesVisitor.attachGenericTypesInfo", "orig_descriptions": [{"description": "Attaches generic type information to a constructor invocation instruction if the instruction's result argument has generic types and the class being instantiated has generic type parameters.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"mth": {"type": "any", "description": "The MethodNode that contains the constructor invocation instruction."}, "insn": {"type": "any", "description": "The ConstructorInsn instance representing the constructor invocation to which generic types info should be attached."}}, "required": ["mth", "insn"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to enrich a constructor invocation instruction with generic type metadata derived from its result argument and the class being instantiated. It should be called only on instructions that represent object construction and have an associated result argument. The tool checks whether the result argument already carries generic type information and whether the target class defines generic type parameters. If both conditions are met, it attaches the corresponding generic type information to the constructor invocation instruction. If either the result argument lacks generic types or the class has no generic parameters, the tool performs no attachment. This tool does not infer or create new generic types, does not modify method bodies beyond the specific constructor invocation instruction, and does not analyze or transform other kinds of instructions.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:03+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "b9f5fc2c658bae43cfad052eabc982e92a3030615bdf94f0e9af880ab9eea61b"}}
{"tool_name": "GeometryPresentation.createPresentation", "orig_descriptions": [{"description": "Initializes the GIS geometry presentation within the provided UI composite, using the given result set controller.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"controller": {"type": "any", "description": "The IResultSetController instance responsible for controlling the result set."}, "parent": {"type": "any", "description": "The Composite UI element where the GIS presentation will be displayed."}}, "required": ["controller", "parent"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Creates and initializes a GIS geometry presentation inside an existing UI container. Use this tool when you need to display or manage geometric data (such as spatial features) that comes from a result set controller, and you already have a UI composite (parent container) where the visualization should appear. This tool sets up the geometry-focused view (for example, map-like or spatial layout) and connects it to the provided result set controller so that the presentation reflects the underlying data and its state.\n\nDo not use this tool to create or modify the result set data itself, to perform spatial analysis, or to manage non-geometry presentations (such as plain tables or charts). It assumes that both the UI composite and the result set controller are already created and valid. Call this tool when the user’s intent is specifically to embed or activate a geometry-centric view within an existing UI context backed by a result set.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:06+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "5555e92e1a0ffa12c165d1cdcc6dccbf73be0a69d31695c57debaa8045c3e266"}}
{"tool_name": "GetPrimeMinisters", "orig_descriptions": [{"description": "Retrieves the current prime ministers' names for a list of specified countries.", "source_files": ["live_simple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["countries"], "properties": {"countries": {"type": "array", "items": {"type": "string"}, "description": "An array of country names for which to retrieve the current prime ministers' names. Each country name should be in the format of its common English full name, such as 'Australia', 'New Zealand', and 'India'."}}}, "source_files": ["live_simple"]}], "source_files": ["live_simple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to know the current prime minister for one or more specific countries. The tool expects a list of country identifiers (for example, country names) and returns the names of the individuals who currently hold the office of prime minister in those countries. It is intended for up-to-date, factual retrieval of present officeholders only.\n\nThis tool does not provide historical data, lists of past prime ministers, or future projections. It also does not return other political roles such as presidents, monarchs, or cabinet members. If a country does not have a prime minister, the tool may return no result or indicate that the role is not applicable.\n\nChoose this tool instead of more general political or biographical tools when the user’s clear intent is: “Who is the current prime minister of X?” or “List the current prime ministers of these countries.”", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:09+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "a29b3b0969148fba1421e958fe1b4be3151cc76de9a86672a34ed28aabb2116e"}}
{"tool_name": "GorillaFileSystem.cat", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.cat", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 510, "num_conversations": 88, "num_as_ground_truth": 44, "aug_description": "Use this tool to read and return the contents of an existing file in the Gorilla file system. Invoke GorillaFileSystem.cat when the user wants to view, inspect, or process the data stored in a file whose path is known (for example, to display code, configuration, logs, or text content). This tool is for non‑modifying, read‑only access: it does not create, edit, append to, or delete files, and it does not list directories. Prefer this tool over others when the primary intent is “show me what is inside this file” rather than managing or transforming files.\n\nArguments: this tool typically expects a file path or identifier (as defined elsewhere in the tool schema) that points to the target file in the Gorilla file system.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:11+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "908a30a794948482527a14ce223ebc0c6f6d358d38a111501cfb66e906c66cd2"}}
{"tool_name": "GorillaFileSystem.cd", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.cd", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 356, "num_conversations": 72, "num_as_ground_truth": 52, "aug_description": "Use this tool when you need to change the current working directory in the Gorilla file system context. It updates the \"current\" location from which subsequent file and directory operations (such as listing, reading, writing, or deleting) will be interpreted.\n\nCall GorillaFileSystem.cd when the user intends to navigate to a different folder/path before performing other file-related actions. This tool does not itself list files, read or write file contents, create or remove directories, or manage permissions; it only changes the active directory reference used by other GorillaFileSystem operations.\n\nChoose this tool over others when the primary intent is directory navigation rather than manipulating files or directories directly. If another tool is for reading, writing, or modifying files, you may need to call GorillaFileSystem.cd first to ensure those operations run in the correct directory.\n\nIf a target path is invalid or inaccessible, the directory change may fail and should be handled accordingly by the calling logic.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:17+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "291d4417c35e1b01cb1717222451219c8bda5731d5a98a875ef7db8fc74afce6"}}
{"tool_name": "GorillaFileSystem.cp", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.cp", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 554, "num_conversations": 92, "num_as_ground_truth": 60, "aug_description": "Use GorillaFileSystem.cp to copy files or directories within the Gorilla file system. Call this tool when you need to duplicate existing content from one path to another, preserving the original while creating a copy at the destination. This tool is specifically for copy operations, not for moving, renaming, deleting, reading, or writing file contents. It should be chosen when the user intent is to replicate data from a source location to a target location in the same file system or a compatible mounted space, assuming both paths are accessible. Do not use this tool for network transfers outside the Gorilla environment or for inspecting file contents. If another tool exists for reading, listing, or modifying data, prefer GorillaFileSystem.cp only when the required action is to create a copy of an existing file or directory structure.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:19+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "fce0103fd0b2c8bdd2f3219f22beb952723a3b3da107f61ddbaf0dd3248ab914"}}
{"tool_name": "GorillaFileSystem.diff", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.diff", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 326, "num_conversations": 48, "num_as_ground_truth": 40, "aug_description": "Compare two versions of files or directories within the Gorilla file system and return their differences.\n\nUse GorillaFileSystem.diff when the user explicitly wants to know what changed between two paths (files or folders) at different locations, revisions, or snapshots, and a textual or structural diff is required. Typical intents include: identifying added, removed, or modified lines in files; understanding changes between two directories; or reviewing modifications before actions like deployment or merging.\n\nDo not use this tool to create, edit, move, or delete files or directories, or to read full file contents for general inspection. It is specifically for comparison, not general file management.\n\nCall this tool when the primary goal is: “Show me the difference between X and Y in the file system,” especially when a precise, machine-readable diff is needed rather than a simple file listing or metadata view.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:22+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "f514709fbb33420ec8f84e1c75812a91974e6313ef9998f90ff5c098155b72c3"}}
{"tool_name": "GorillaFileSystem.echo", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.echo", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 346, "num_conversations": 64, "num_as_ground_truth": 44, "aug_description": "Use GorillaFileSystem.echo when you need the system to immediately return or \"echo\" back a given input string, mainly for testing, debugging, or confirming connectivity and basic tool invocation. This tool is appropriate when the user intent is to verify that text can be passed through the GorillaFileSystem interface unchanged, or to confirm that other tools are not required yet.\n\nIt does not read, write, list, modify, or otherwise interact with any files, directories, or persistent storage. It performs no filesystem side effects and should not be used for real file operations, data processing, or content transformation.\n\nChoose GorillaFileSystem.echo instead of other GorillaFileSystem tools when the only requirement is to see the same text returned, for example to test argument wiring, prompt routing, or the basic behavior of the environment without touching the actual filesystem.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:25+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "4e4ece69cfb7e2707889b9cdc1802d16c949fd6b7acf9eecad8001aec0ad1537"}}
{"tool_name": "GorillaFileSystem.find", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.find", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 490, "num_conversations": 80, "num_as_ground_truth": 24, "aug_description": "Use this tool to search within the Gorilla file system for files or directories that match given criteria. Call GorillaFileSystem.find when the user wants to locate existing files, check whether something exists, or discover paths based on names, patterns, or similar search conditions. This tool is for querying the file system only; it does not create, modify, move, or delete files or directories. It should be chosen over tools that read file contents, write data, or manage file metadata when the primary intent is simply to find where something is stored. Typical intents include: “Where is file X?”, “Does a file named Y exist?”, or “List all files matching this pattern.” If other GorillaFileSystem tools exist for reading, writing, or listing directories without search filters, prefer GorillaFileSystem.find specifically when a search operation or targeted lookup is required rather than a simple, unfiltered directory listing.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:28+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "6724e571ae67a571fb830c253d8c66b551f1823a90b46d5f878d8a8e0782986d"}}
{"tool_name": "GorillaFileSystem.grep", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.grep", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 466, "num_conversations": 76, "num_as_ground_truth": 40, "aug_description": "Use GorillaFileSystem.grep when you need to search within files for text patterns or specific strings, similar to a traditional “grep” operation in a file system. This tool is appropriate when the user’s intent is to find occurrences of a keyword, phrase, or pattern across one or more files that are accessible through the GorillaFileSystem context.\n\nChoose this tool when the task involves content-based search (e.g., locating lines containing a term, filtering by a pattern) rather than file management operations such as creating, deleting, moving, or listing files and directories. It does not modify files, change permissions, or read/write file contents beyond what is required to perform the search.\n\nDo not use this tool for general file listing, downloading, or uploading; use it specifically when the key requirement is to identify matches of textual content inside files. The typical user intent is: “Search these files for X” or “Find where this pattern appears in the project’s files.”", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:31+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "4d39485569727979e0fde3fe9b4b8e61a113aa1653ae1dbdb1734ec636f1c5ca"}}
{"tool_name": "GorillaFileSystem.ls", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.ls", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 192, "num_conversations": 36, "num_as_ground_truth": 20, "aug_description": "Use GorillaFileSystem.ls when you need to list the contents of a directory in the file system managed by GorillaFileSystem. This tool is intended for discovering which files or subdirectories exist at a given path, checking what is available before performing further file operations such as reading, writing, or deleting. It does not create, modify, or delete files or directories; it only enumerates them. Call this tool when the user asks what files are present, wants to browse a folder, or needs to verify that a particular file or directory exists in a location. Do not use this tool to read file contents, change file metadata, upload/download data, or perform searches across multiple directories. It is specifically for listing entries in a given directory path within the GorillaFileSystem environment.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:33+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "8560b9eb0582450ea75a3995a585b0a8e23cdff327f8b1c1012a75c2b222894c"}}
{"tool_name": "GorillaFileSystem.mkdir", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.mkdir", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 290, "num_conversations": 44, "num_as_ground_truth": 16, "aug_description": "Creates a directory in the Gorilla file system. Use GorillaFileSystem.mkdir when the user explicitly wants to create a new folder/path at a specified location in the file system. This tool is appropriate for organizing files, preparing a directory structure before saving content, or ensuring a path exists prior to other file operations.\n\nGorillaFileSystem.mkdir does not read, write, modify, or delete files or directories; it only creates a directory. It should not be used for listing contents, checking existence, moving/copying data, or removing directories. If the intent involves file content manipulation or directory inspection, another, more suitable file-related tool should be chosen.\n\nTypical user intents include: “create a folder,” “make a directory,” or “ensure this path exists.” Call this tool only when directory creation is clearly required, and rely on other tools for any subsequent file or directory operations beyond creation.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:36+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "66ee2a935244f7b222e61115654c82810bea2a48327d3706dba8103e1d438b07"}}
{"tool_name": "GorillaFileSystem.mv", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.mv", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 682, "num_conversations": 108, "num_as_ground_truth": 56, "aug_description": "Moves or renames a file or directory within the Gorilla file system. Use GorillaFileSystem.mv when the user wants to change the location or name of an existing file or folder, while keeping its contents intact. This tool should be selected for operations such as reorganizing files, cleaning up directory structures, or updating file paths referenced elsewhere.\n\nDo not use this tool to copy data (use a copy-related tool instead) or to delete content (use a delete-related tool instead). It does not create new files from scratch, read file contents, or modify file data; it only changes where an existing item is stored or what it is called. The source path must already exist, and the destination path must be valid in the Gorilla file system. If a tool is needed to upload, download, read, or edit files, choose a different GorillaFileSystem tool designed for that purpose.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:39+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "584f3a3bf36fe0ce940c6bb2ef37f03e3cb0678c25cb33d09cc08fc9d1ed1643"}}
{"tool_name": "GorillaFileSystem.rm", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.rm", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 36, "num_conversations": 8, "num_as_ground_truth": 0, "aug_description": "Deletes a file or directory from the Gorilla file system.\n\nUse GorillaFileSystem.rm when you need to remove an existing path (such as cleaning up intermediate outputs, deleting obsolete files, or removing temporary directories) and you no longer need their contents. This tool is for deletion only and should be chosen when the explicit user intent is to permanently remove data at a specified location.\n\nThis tool does not read, write, list, move, copy, or modify file contents; it only removes the specified target. It also does not create directories or files. If there are other tools for reading, writing, listing, or moving files, do not use GorillaFileSystem.rm for those tasks.\n\nCall this tool when the user clearly requests actions like “delete,” “remove,” “erase,” or “clean up” specific filesystem paths in the Gorilla environment.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:42+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "727d08706ae6e0e662e6cba1fa8a52a9351931e51d1fae1c717e6e9994dff909"}}
{"tool_name": "GorillaFileSystem.sort", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.sort", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 588, "num_conversations": 96, "num_as_ground_truth": 32, "aug_description": "Use GorillaFileSystem.sort when you need to sort or reorder items within a file-system-like structure managed by GorillaFileSystem. This tool is intended for operations where the primary goal is to change the ordering of files, directories, or entries (for example, alphabetically, by size, by date, or by a specified custom order), assuming such parameters are supported by its arguments.\n\nCall this tool when the user explicitly asks to sort, reorder, or organize file listings or directory contents, rather than to read, write, move, delete, or rename them. Do not use this tool for searching, filtering, content inspection, or metadata modification other than ordering. If another tool handles creation, deletion, or content editing, prefer that other tool; use GorillaFileSystem.sort only when the result is a changed sequence or ordering of existing items within the GorillaFileSystem context.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:45+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "acd184d162460f85ff9ffbaeeff535a3cabe0c0641ebdaa9b6b7fda882c6583c"}}
{"tool_name": "GorillaFileSystem.tail", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.tail", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 292, "num_conversations": 48, "num_as_ground_truth": 24, "aug_description": "Use this tool to read and return the last part (the “tail”) of a file in the Gorilla file system. Call GorillaFileSystem.tail when the user wants to inspect the end of a log, text file, or other file-based output that already exists in the file system, especially for debugging, recent events, or final lines of data.\n\nThis tool is for reading only and does not create, modify, or delete files. It does not list directories, search for files, or read arbitrary byte ranges from the middle of a file. Do not use it to write content or to upload/download files outside the Gorilla file system.\n\nChoose GorillaFileSystem.tail instead of more general file read tools when the user is specifically interested in the most recent lines or trailing content, not the entire file. If the user’s request is about “last lines,” “tail,” “recent logs,” or “end of file,” this is the appropriate tool to call.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:51+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "32a581380215fa5f27d64f668c64346251b872cb85e649a7b20f7d823b54adc4"}}
{"tool_name": "GorillaFileSystem.touch", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.touch", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 340, "num_conversations": 60, "num_as_ground_truth": 48, "aug_description": "Use this tool to create an empty file at a specified path or to update the timestamp of an existing file in the Gorilla file system. Call GorillaFileSystem.touch when the user explicitly wants to create a new file placeholder, ensure a file exists before writing with other tools, or refresh the modification time of a file without changing its contents.\n\nDo not use this tool for writing data, reading file contents, deleting files, listing directories, or moving/renaming files; those actions should be handled by other, more appropriate filesystem tools. This tool only affects file existence and/or metadata (such as timestamps), depending on the underlying environment behavior.\n\nSelect GorillaFileSystem.touch when the key user intent is: “create this file if it doesn’t exist” or “touch/refresh this file’s timestamp” rather than manipulating file contents or directory structures.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:54+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "a6f87de97966dbf7e99a5b419dd2048f7a012618e1f8147d3652b1b4ace1a619"}}
{"tool_name": "GorillaFileSystem.wc", "orig_descriptions": [{"description": "BFCL available function: GorillaFileSystem.wc", "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "parameters_variants": [{"parameters": {}, "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"]}], "source_files": ["multi_turn_base", "multi_turn_long_context", "multi_turn_miss_func", "multi_turn_miss_param"], "task_types": ["multi_turn"], "num_occurrences": 438, "num_conversations": 72, "num_as_ground_truth": 56, "aug_description": "Use GorillaFileSystem.wc to count textual elements (similar to a word/line/character count) for files or content managed by the Gorilla file system layer. This tool is intended when the user asks for counts of words, lines, characters, or similar metrics within one or more files or file-like resources under GorillaFileSystem control.\n\nDo not use this tool to read, write, modify, move, or delete files; it is only for obtaining size/count statistics. Also do not use it for general text analysis (such as sentiment, summarization, or keyword extraction) beyond simple counting. If the user’s intent is to inspect file content or structure, another GorillaFileSystem operation is more appropriate.\n\nChoose GorillaFileSystem.wc when the request explicitly involves “how many words/lines/characters” or “size in terms of text units” for a file or collection of files accessible through the Gorilla environment.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:56+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "038dd1e6fa21238d811ee82100a58b85cb8cce1507909dfd2ba81d524e16f61f"}}
{"tool_name": "HNA_COOKBOOK.search_recipe", "orig_descriptions": [{"description": "Search for cooking recipes based on a given keyword. The function returns a list of recipes that match the keyword criteria.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["keyword"], "properties": {"keyword": {"type": "string", "description": "The keyword to search for in recipes. It could be an ingredient, dish name, or cuisine type."}, "max_results": {"type": "integer", "description": "The maximum number of recipe results to return. Defaults to 10.", "default": 10}, "include_instructions": {"type": "boolean", "description": "Whether to include cooking instructions in the search results. Defaults to false.", "default": false}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 0, "aug_description": "Use this tool when the user wants to find cooking recipes related to a specific term, ingredient, dish name, cuisine, or style by providing a keyword. The tool searches a recipe collection and returns a list of recipes whose textual data matches that keyword. It is suitable for intents like: “find pasta recipes,” “recipes with chicken,” or “desserts with chocolate.” The tool does not cook, plan full meal schedules, generate arbitrary text instructions from scratch, or modify existing recipes; it only searches and retrieves recipes that already exist in the underlying collection based on the supplied keyword. If the user asks to browse, discover, or look up recipes by a word or short phrase, choose this tool. If the user instead wants to create a completely new custom recipe without searching existing ones, this is not the right tool.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:35:59+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "a556f3e50a20a9a3e35ddd53d091e080678528985fe65b9d201ba27faced41f4"}}
{"tool_name": "HNA_NEWS.search", "orig_descriptions": [{"description": "Searches for recent events and news based on the specified keyword.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Search for recent events, news, and other relevant content based on a specified keyword.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["keyword"], "properties": {"keyword": {"type": "string", "description": "The key term used to search for relevant news articles."}, "category": {"type": "string", "description": "The category to filter news articles by.", "enum": ["General", "Politics", "Economy", "Sports", "Technology", "Entertainment"], "default": "General"}, "date_range": {"type": "string", "description": "The date range for the news search, formatted as 'YYYY-MM-DD to YYYY-MM-DD'.", "default": "null"}, "sort_by": {"type": "string", "description": "The sorting order of the search results.", "enum": ["date", "relevance"], "default": "date"}, "language": {"type": "string", "description": "The language of the news articles to retrieve.", "enum": ["EN", "FR", "ES", "DE", "IT"], "default": "EN"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["keyword"], "properties": {"keyword": {"type": "string", "description": "The keyword used for searching recent news and events."}, "category": {"type": "string", "description": "The category to filter the news search results.", "enum": ["World", "Local", "Business", "Technology", "Entertainment", "Sports"], "default": "World"}, "language": {"type": "string", "description": "The language preference for the news results, formatted as an ISO 639-1 two-letter language code.", "default": "en"}, "limit": {"type": "integer", "description": "The maximum number of news results to return.", "default": 10}, "sort_by": {"type": "string", "description": "The sort order of the news results.", "enum": ["Relevance", "Date"], "default": "Date"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["keyword"], "properties": {"keyword": {"type": "string", "description": "The key term used to search for relevant news articles."}, "category": {"type": "string", "description": "The category to filter news articles by.", "enum": ["Politics", "Economy", "Sports", "Technology", "Entertainment"], "default": "General"}, "date_range": {"type": "string", "description": "The date range for the news search, formatted as 'YYYY-MM-DD to YYYY-MM-DD'.", "default": "null"}, "sort_by": {"type": "string", "description": "The sorting order of the search results.", "enum": ["date", "relevance"], "default": "date"}, "language": {"type": "string", "description": "The language of the news articles to retrieve.", "enum": ["EN", "FR", "ES", "DE", "IT"], "default": "EN"}}}, "source_files": ["live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 22, "num_conversations": 19, "num_as_ground_truth": 5, "aug_description": "Use this tool to find recent news articles and events related to a specific topic by keyword. It is appropriate when the user wants up-to-date information, headlines, or reports about people, companies, technologies, markets, geopolitical events, or other current issues. The tool focuses on recency, so prefer it when the user asks about “latest,” “recent,” “current,” or “today’s” developments rather than historical or background information.\n\nThis tool does not summarize arbitrary documents, browse general web pages, or provide in-depth analysis beyond what is contained in recent news coverage. It should not be used for tasks like fact-checking non-news claims, retrieving academic papers, or answering questions that are clearly timeless (for example, definitions or how-to guides).\n\nTrigger this tool whenever the user’s intent is to know what has happened or is happening now around a topic, and a keyword or phrase can represent that topic.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:36:02+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "9a532cdd3df45d17bc317cd42d202c9314ebdb958b2053309c5c9341a63ae87b"}}
{"tool_name": "HNA_WQA.query", "orig_descriptions": [{"description": "Responds to queries that require web searches to obtain current and time-sensitive information, such as the current president, recent movies, or top songs.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["keyword"], "properties": {"keyword": {"type": "string", "description": "The search term used to query the web for up-to-date information."}, "result_limit": {"type": "integer", "description": "The maximum number of search results to return. A lower number can lead to faster responses.", "default": 5}, "language": {"type": "string", "description": "The language in which to return search results.", "enum": ["en", "es", "fr", "de", "zh"], "default": "en"}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 0, "aug_description": "Use this tool to answer user questions that require up-to-date, time-sensitive, or recently changed information from the web. Typical uses include current office holders or leaders, recent events, newly released products or media, live rankings, current prices, or anything where data may have changed since the last static update. The tool is appropriate when the user explicitly asks for “current,” “latest,” “recent,” “today,” or similar time-focused information, or when you suspect static knowledge may be outdated.\n\nDo not use this tool for questions that can be reliably answered from general, timeless knowledge (for example, historical facts, math, definitions, or stable scientific concepts) unless the user specifically asks for the most recent status or recent developments.\n\nThis tool performs web-based information retrieval only and should be used when you need external, current data to produce an accurate answer.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:36:05+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "8f3198795bebc36cf85541d06089e05bad153c714f13d57054afdf089080b14f"}}
{"tool_name": "HNA_WQA.search", "orig_descriptions": [{"description": "Retrieve up-to-date information by searching the web using keywords. This is particularly useful for queries regarding topics that change frequently, such as the current president, recent movies, or popular songs.", "source_files": ["live_multiple", "live_parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["keyword"], "properties": {"keyword": {"type": "string", "description": "The search term used by the HNA WQA to find relevant information on the web."}, "result_format": {"type": "string", "description": "The desired format of the search results.", "enum": ["text", "json", "xml"], "default": "text"}, "language": {"type": "string", "description": "The language preference for the search results.", "enum": ["EN", "ES", "FR", "DE"], "default": "EN"}, "max_results": {"type": "integer", "description": "Maximum number of search results to return.", "default": 10}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 20, "num_conversations": 17, "num_as_ground_truth": 5, "aug_description": "Use this tool to search the web for up-to-date, factual information based on user-provided keywords. It is appropriate when the user’s question depends on current or frequently changing data (for example: recent news, current office holders, latest product releases, trending media, or updated statistics) or when the answer is not reliably covered by static knowledge. Invoke this tool when you need to verify current status, confirm recent events, or gather information that may have changed after the model’s knowledge cutoff. Do not use this tool for tasks that only require reasoning over already known or timeless facts, for performing calculations, or for manipulating data you already have. The tool expects well-formed keyword queries and returns search-based results that you should then interpret, summarize, or reason about for the user.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T16:36:08+00:00", "prompt_hash": "a963354559532cc1614195ba700276a9ef856dfb161f9f3c559b9c374b3768b8", "parse_mode": "json_ok", "raw_output_hash": "bd531dc5c2f02730c01d8eaca08ce62212c5994246b9b119f02051bfe2c9153f"}}
