{"tool_name": "AbstractJarAgent.runJarAgent", "orig_descriptions": [{"description": "Runs the jar agent with the specified options and attaches it to the provided Instrumentation instance. It initializes common parameters, performs test-specific initialization, and starts a special thread for test-specific actions.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"options": {"type": "String", "description": "The options for the jar agent, separated by spaces."}, "inst": {"type": "any", "description": "The Instrumentation instance to which the agent will be attached."}}, "required": ["options", "inst"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to start a preconfigured JAR-based agent within a running JVM context that already has an Instrumentation instance. Call AbstractJarAgent.runJarAgent when the user intent is to attach and run the agent with given options, so it can set up common state, run any test- or scenario-specific initialization, and then launch a dedicated thread that performs ongoing or deferred test-related actions.\n\nThis tool does not create or configure the Instrumentation instance itself and does not load arbitrary JARs; it expects that the appropriate agent JAR and Instrumentation are already available and focuses only on initializing and starting that agent with the supplied options. Do not use this tool for general process control, class loading unrelated to the agent, or for non-agent JAR execution. It is specifically for running the predefined jar agent logic that depends on Instrumentation and may include test or monitoring behavior.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:11+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "953f702f8b01225a08d776681bf137449ba317193d8967f99f61cb07c2dcc7f8"}}
{"tool_name": "AbstractTransportSearchableSnapshotsAction.shardOperation", "orig_descriptions": [{"description": "Executes a shard-level operation on a searchable snapshot, ensuring the license is valid and the directory is correctly unwrapped before performing the operation.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"request": {"type": "any", "description": "The request to perform the shard operation."}, "shardRouting": {"type": "any", "description": "The ShardRouting information for the shard on which to perform the operation."}, "task": {"type": "any", "description": "The task associated with the shard operation."}, "listener": {"type": "any", "description": "The ActionListener that will handle the ShardOperationResult asynchronously."}}, "required": ["request", "shardRouting", "task", "listener"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Executes a shard-level operation that targets a searchable snapshot. Use this tool when you need to perform an action on a specific shard that is backed by a searchable snapshot, and the action must only proceed if licensing and storage preconditions are satisfied.\n\nBefore running the core shard operation, this tool validates that the required license for searchable snapshots is present and that the underlying shard directory is correctly unwrapped and accessible. If these preconditions are not met, the shard operation is not performed.\n\nThis tool does not create, restore, or manage snapshots themselves, and it does not operate on indices or clusters as a whole. It is only for executing an already-defined shard operation in the context of a searchable snapshot, after checking license and directory readiness. Use other tools for snapshot lifecycle management, index-level operations, or non-snapshot shard actions.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:13+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "3b7bd5a5c7824463392dc4d020723569581e636029520c7022ef8cde2413d7d8"}}
{"tool_name": "AclApi.add_mapping", "orig_descriptions": [{"description": "Adds an Access Control List (ACL) mapping to define permissions for users or groups on specified resources.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["resource_id", "user_id", "permissions"], "properties": {"resource_id": {"type": "string", "description": "The unique identifier for the resource to which the ACL mapping will be applied."}, "user_id": {"type": "string", "description": "The unique identifier of the user or group that the ACL mapping will be associated with."}, "permissions": {"type": "array", "items": {"type": "string"}, "description": "A list of permission strings that define the access level for the user or group on the resource."}, "expiry_date": {"type": "string", "description": "The expiration date for the ACL mapping in the format 'YYYY-MM-DD'. Optional, defaults to null which indicates no expiration.", "default": null}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to create a new access control mapping that defines which permissions a user or group has on specific resources. Call AclApi.add_mapping when you need to grant, adjust, or formalize access for principals (such as users or groups) to resources (such as objects, collections, or services) by establishing a new ACL entry.\n\nThis tool is for adding mappings only; it does not update or delete existing mappings and does not evaluate or check current permissions. It also does not perform authentication or identity verification; it assumes the caller already knows the correct user or group identifiers and target resources.\n\nTypical user intent includes: granting a user read or write access to a resource, assigning a group specific permissions to a collection of resources, or setting up default permissions for newly created entities. Use this tool when the goal is to persist new permission relationships, not to query, list, or remove them.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:15+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "2e9f720163a4ad67b7c24dc9fe8f3de4cc7f5499d9b6f3f5534135b12792f2c1"}}
{"tool_name": "Alarm_1_AddAlarm", "orig_descriptions": [{"description": "Sets a new alarm with specified time and an optional custom name.", "source_files": ["live_multiple"]}, {"description": "Set a new alarm with a specified time and optional custom name.", "source_files": ["live_multiple"]}, {"description": "This function sets a new alarm with a specified time and an optional custom name.", "source_files": ["live_multiple"]}, {"description": "This function sets a new alarm with a specified time and an optional name.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["new_alarm_time"], "properties": {"new_alarm_time": {"type": "string", "description": "The time to set for the new alarm in 24-hour format (e.g., '14:30' for 2:30 PM)."}, "new_alarm_name": {"type": "string", "description": "The custom name to assign to the new alarm.", "default": "New Alarm"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["new_alarm_time"], "properties": {"new_alarm_time": {"type": "string", "description": "The time to set for the new alarm in 24-hour format (HH:MM)."}, "new_alarm_name": {"type": "string", "description": "The custom name to assign to the new alarm.", "default": "New alarm"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["new_alarm_time"], "properties": {"new_alarm_time": {"type": "string", "description": "The time to set for the new alarm in 24-hour format 'HH:MM'."}, "new_alarm_name": {"type": "string", "description": "The name to assign to the new alarm. Helps identify alarms easily.", "default": "New alarm"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["new_alarm_time"], "properties": {"new_alarm_time": {"type": "string", "description": "The time to set for the new alarm, in 24-hour format 'HH:MM'."}, "new_alarm_name": {"type": "string", "description": "The custom name to give to the new alarm.", "default": "New alarm"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["new_alarm_time"], "properties": {"new_alarm_time": {"type": "string", "description": "The time to set for the new alarm, in 24-hour format (HH:MM)."}, "new_alarm_name": {"type": "string", "description": "The label to assign to the new alarm.", "default": "New alarm"}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 60, "num_conversations": 60, "num_as_ground_truth": 6, "aug_description": "Use this tool to create a new alarm at a specific time, optionally giving it a custom name. Call this when the user explicitly wants to be alerted at a future time (for example, waking up in the morning, reminding them about an event, or timing an activity) and they are not asking to modify or delete an existing alarm.\n\nThe tool only sets a new alarm; it does not list, update, rename, or cancel existing alarms, and it does not handle countdown timers or stopwatches. If the user request involves changing or removing a previously set alarm, do not use this tool.\n\nTypical triggers: the user says they want to \"set an alarm\" or \"add an alarm\" for a particular time, optionally with a label or purpose. The custom name, if provided, should reflect the users described reason or label for the alarm. If the user does not specify a name, rely on the default behavior of the tool.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:18+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "5ef8266f5adf3874e5b149e410d487fca46a25228c2eeb6ab27524b75dc69922"}}
{"tool_name": "Alarm_1_GetAlarms", "orig_descriptions": [{"description": "Retrieve a list of all alarms that the user has set in the application.", "source_files": ["live_multiple"]}, {"description": "Retrieve a list of alarms that the user has set in the system.", "source_files": ["live_multiple"]}, {"description": "Retrieves a list of alarms that the user has set in the system.", "source_files": ["live_multiple"]}, {"description": "Retrieve a list of alarms that the user has configured on the device, including details such as time, label, and status.", "source_files": ["live_multiple"]}, {"description": "Retrieves the list of alarms that the user has set within the application.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "The unique identifier for the user whose alarms are being retrieved."}, "include_disabled": {"type": "boolean", "description": "A flag indicating whether to include disabled alarms in the result set.", "default": false}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "Unique identifier for the user whose alarms are to be fetched."}, "include_disabled": {"type": "boolean", "description": "Whether to include disabled alarms in the result.", "default": false}, "alarm_type": {"type": "string", "description": "The type of alarms to retrieve.", "enum": ["sound", "vibration", "visual"], "default": "sound"}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "The unique identifier of the user whose alarms are to be retrieved."}, "include_disabled": {"type": "boolean", "description": "A flag indicating whether disabled alarms should be included in the response.", "default": false}, "alarm_type": {"type": "string", "description": "The type of alarms to retrieve, such as 'wake', 'reminder', or 'timer'.", "enum": ["wake", "reminder", "timer"], "default": "wake"}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "The unique identifier of the user whose alarms are to be retrieved."}, "include_disabled": {"type": "boolean", "description": "Flag to include disabled alarms in the list.", "default": false}, "date": {"type": "string", "description": "Filter alarms by the set date, in the format of 'YYYY-MM-DD'. If not provided, defaults to current date.", "default": null}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"user_id": {"type": "integer", "description": "The unique identifier for the user whose alarms are being fetched."}, "include_disabled": {"type": "boolean", "description": "A flag to include alarms that are currently disabled.", "default": false}, "sort_order": {"type": "string", "description": "The order in which the alarms should be sorted.", "enum": ["ascending", "descending"], "default": "ascending"}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 60, "num_conversations": 60, "num_as_ground_truth": 5, "aug_description": "Use this tool to retrieve all alarms that the user has already created in the application. It returns a list of existing alarms without requiring any input arguments.\n\nCall this tool when the user asks to see, review, manage, or confirm their current alarms, such as checking what alarms are set, verifying times or labels, or deciding which alarm to modify or delete with other tools.\n\nThis tool only reads and lists alarms; it does not create, modify, enable/disable, or delete alarms. If the user wants to add a new alarm, change an existing one, or remove an alarm, choose a different tool dedicated to those actions.\n\nThe output should be used when you need an up-to-date snapshot of all alarms before making further changes or answering questions about them.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:20+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "67a6b7ad5e15510aac22f66d17b45a517aea931480ab714a8ea90b54515e8be4"}}
{"tool_name": "Alltransactions", "orig_descriptions": [{"description": "Retrieve a list of all transactions for a specified statement period.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["statement_period"], "properties": {"statement_period": {"type": "string", "description": "The statement period for which transactions are to be retrieved, in the format 'YYYY-MM'."}, "include_pending": {"type": "boolean", "description": "A flag to determine if pending transactions should be included in the list.", "default": false}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to retrieve a list of all transactions for a specified statement period on an account. Call this tool when the user wants to see every transaction within a particular billing or statement cycle, such as for reviewing spending, reconciling charges, or exporting history for that period.\n\nThis tool returns all transactions that fall inside the defined statement period, not just a single transaction or a summary total. It is appropriate when the user is asking for a full statement view or a complete transaction history for one period, rather than filtering by specific categories, individual transaction IDs, or custom date ranges.\n\nDo not use this tool if the user only needs details about one transaction, needs to search by transaction metadata, or wants aggregated analytics like totals by category. It should be chosen when the key intent is: \"Show me everything that happened in this statement period.\"", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:22+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "ef6521322b3294fc52ea76d693c2bd8016db87e0da5de811573f8c3f84c5c051"}}
{"tool_name": "AltibaseGrantee.prepareObjectsStatement", "orig_descriptions": [{"description": "Prepares a JDBC statement for querying system privileges and their grantors for a given Altibase grantee.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"session": {"type": "any", "description": "The JDBC session in which to prepare the statement."}, "owner": {"type": "any", "description": "The Altibase grantee whose system privileges and grantors are to be queried."}}, "required": ["session", "owner"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to build a JDBC statement that retrieves system privileges and their grantors for a specific Altibase database grantee (such as a user or role). It prepares, but does not execute, the SQL needed to query Altibase system catalogs for which system privileges the grantee has and who granted them. This tool should be selected when the user intent is to inspect or analyze system-level privileges (not object-level privileges) associated with an Altibase grantee, typically for security auditing, access review, or privilege reporting.\n\nDo not use this tool for modifying privileges, granting/revoking permissions, or querying non-Altibase databases. It does not handle schema objects, table privileges, data manipulation, or transaction control. The output is a ready-to-use JDBC statement that another component can execute to obtain the actual privilege data.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:25+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "a09e024b6720317e5358c19459ed07c1cfa3172dffbc5765dce0af3f81cb9e7e"}}
{"tool_name": "AmazonGameStore.recommend", "orig_descriptions": [{"description": "Generate game recommendation from Amazon Game Store based on number of players and category.", "source_files": ["multiple", "parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"numOfPlayers": {"type": "integer", "description": "The number of players who will play the game."}, "category": {"type": "string", "description": "The preferred category of board game. E.g. strategy, family, party etc."}, "priceRange": {"type": "string", "description": "The price range you are willing to pay for the board game. E.g. $10-$20, $20-$30 etc. This is an optional parameter. Default ''"}}, "required": ["numOfPlayers", "category"]}, "source_files": ["multiple"]}, {"parameters": {"type": "dict", "properties": {"numOfPlayers": {"type": "integer", "description": "The number of players who will play the game."}, "category": {"type": "string", "description": "The preferred category of board game. E.g. strategy, family, party etc."}, "priceRange": {"type": "string", "description": "The price range you are willing to pay for the board game. E.g. $10-$20, $20-$30 etc. This is an optional parameter. Default to '$10-$20' if not specified."}}, "required": ["numOfPlayers", "category"]}, "source_files": ["parallel_multiple"]}], "source_files": ["multiple", "parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 5, "num_conversations": 2, "num_as_ground_truth": 2, "aug_description": "Use this tool when a user wants recommendations for video games available in the Amazon Game Store, specifically filtered by number of players and by game category. This tool is appropriate when the user expresses preferences like playing solo, with friends, or in a party, and/or requests genres or categories such as action, strategy, sports, family, etc., and wants concrete game suggestions. It focuses on recommending titles, not on purchasing, pricing, downloading, or reviewing games.\n\nCall this tool when the main intent is: \"What game should I play/buy on Amazon Game Store given my player count and preferred category?\" Do not use this tool for non-game products, for platforms outside the Amazon Game Store, or for tasks like troubleshooting, account issues, or system requirements analysis. The output should help the user decide which games fit their desired play style (solo, co-op, multiplayer) and category from Amazon Game Store offerings.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:27+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "c9ac9de18082bcfebb323067bdb02300493388712e7f93cbe0685cc836aafb0a"}}
{"tool_name": "ApplicationAnalyzeApi.get_call_details", "orig_descriptions": [{"description": "Retrieve the details of a specific call using its trace ID and call ID.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["traceId", "callId"], "properties": {"traceId": {"type": "string", "description": "The unique identifier for the trace of the call."}, "callId": {"type": "string", "description": "The unique identifier for the individual call within a trace."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to retrieve detailed information about a specific recorded call in an application by referencing both its trace ID and call ID. This is appropriate when you already know the exact trace and call identifiers and need granular data about that single call, such as for debugging, auditing, or analyzing behavior within a larger trace. It does not list multiple calls, search by other attributes, or modify any data; it only returns details for the one call that matches the provided identifiers. Choose this tool when the user intent is to inspect or understand one particular call instance within a trace, rather than to query aggregates, metrics, or overviews of multiple calls or traces.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:29+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "d6af401da532b5b10558dda7d4f2ced842e9d10cf28a7ef3f8d3a05d99351e47"}}
{"tool_name": "ApplicationAnalyzeApi.get_correlated_traces", "orig_descriptions": [{"description": "Retrieve backend trace IDs corresponding to the provided correlation IDs from website and mobile app monitoring data.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["correlationId"], "properties": {"correlationId": {"type": "string", "description": "The unique identifier used for correlating traces between backend and monitoring systems, typically a UUID."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool when you need to map frontend or client-side correlation IDs (from website or mobile app monitoring) to the corresponding backend trace IDs. This is typically used to connect user-facing events, sessions, or requests with their server-side traces for debugging, performance analysis, or end-to-end request tracking.\n\nThis tool only performs the correlation from given correlation IDs to backend trace IDs; it does not fetch full trace details, metrics, logs, or any other telemetry. If you already have backend trace IDs and need more information about those traces, do not use this tool.\n\nCall this tool when the user intent is to: link mobile or web requests to backend traces, investigate a specific user interaction across services, or continue analysis in another tool that requires backend trace IDs as input.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:31+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "cc4b33205d8e86c4114a48281620612d8fdb4d16e324d6c20910aa21e26cc18f"}}
{"tool_name": "ApplicationAnalyzeApi.get_trace_download", "orig_descriptions": [{"description": "Retrieves detailed information about a trace with a specified ID, allowing for optional pagination.", "source_files": ["live_multiple"]}, {"description": "Retrieves detailed information about a specific trace from an application analysis system by trace ID. The response includes trace data up to a specified retrieval size, starting from a given offset. The data can be filtered based on the time of ingestion.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["id"], "properties": {"id": {"type": "string", "description": "The unique identifier for the trace."}, "retrievalSize": {"type": "integer", "description": "The number of trace entries to retrieve in one call. Defaults to 100 if not specified.", "default": 100}, "offset": {"type": "integer", "description": "The offset from the start of the trace data used for paginating results. Defaults to 0 to start from the beginning.", "default": 0}, "ingestionTime": {"type": "string", "description": "The timestamp representing when the trace was ingested. Format should be in UTC ISO 8601, such as '2023-01-15T00:00:00Z'. If not specified, defaults to the current time.", "default": null}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["id"], "properties": {"id": {"type": "string", "description": "The unique identifier of the trace to retrieve."}, "retrievalSize": {"type": "integer", "description": "The maximum number of trace entries to retrieve.", "default": 100}, "offset": {"type": "integer", "description": "The offset from which to start retrieving trace entries.", "default": 0}, "ingestionTime": {"type": "string", "description": "The ingestion time to filter the trace data, formatted as an ISO 8601 timestamp, such as '2023-03-25T13:00:00Z'.", "default": null}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 1, "aug_description": "Use this tool to retrieve detailed information about a specific application trace when you know its trace ID. This is typically used for debugging, performance analysis, or auditing a single trace instance, not for listing or searching multiple traces.\n\nCall this tool when the user asks to download or inspect the full contents or metadata of one trace, possibly in segments if the trace is large. The tool supports optional pagination, so it can return trace data in parts rather than all at once. Use pagination-related arguments only when the user needs to navigate through different portions or pages of a large trace.\n\nDo not use this tool to start, stop, or modify tracing, and do not use it to list or filter many traces at once. It is read-only and focused on one existing trace identified by its ID.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:33+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "7df995f4203dbc3dc5a85f4c08a18c2639389fc2ca3c4c811892455bf36569b9"}}
{"tool_name": "ApplicationSettingsApi.get_application_configs", "orig_descriptions": [{"description": "Retrieve all configuration settings for the application, including environment variables, feature toggles, and system behaviors.", "source_files": ["live_multiple"]}, {"description": "Retrieve all configuration settings for the application. This includes settings such as feature toggles, system behaviors, and user preferences.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["environment"], "properties": {"environment": {"type": "string", "description": "The deployment environment for which the application configurations are being retrieved, such as 'development', 'staging', or 'production'.", "enum": ["development", "staging", "production"]}, "include_sensitive": {"type": "boolean", "description": "A flag indicating whether to include sensitive configurations like API keys and passwords. It is recommended to keep this false unless necessary.", "default": false}, "config_type": {"type": "string", "description": "The type of configurations to retrieve, such as 'feature_toggles' or 'system_behaviors'.", "enum": ["all", "feature_toggles", "system_behaviors"], "default": "all"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"environment": {"type": "string", "description": "The application environment for which the configurations are to be fetched, e.g., 'production', 'staging', or 'development'.", "enum": ["production", "staging", "development"], "default": "production"}, "include_sensitive": {"type": "boolean", "description": "Flag to determine if sensitive configurations such as API keys and passwords should be included in the response.", "default": false}}, "required": []}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 0, "aug_description": "Use this tool to read the full set of configuration settings for the application. It returns a comprehensive view of current configs, including environment variables, feature toggles, and system behavior flags that control how the application runs.\n\nCall this tool when the user wants to inspect or audit existing configuration values, understand which features are enabled or disabled, or see environment-specific settings that are already in effect.\n\nThis tool is read-only: it does not modify, create, or delete any configuration, and it does not deploy or restart anything. Do not use it for updating settings, changing feature toggles, or writing new environment variables. It is intended solely for retrieving the current configuration state in one call, not for partial or filtered queries unless such behavior is defined by the implementation.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:35+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "eec2bbe8b526c4d2ff4732ff67acd915623b8db287cdf13cb954356b59fcd0c0"}}
{"tool_name": "ApplicationSettingsApi.get_service_configs", "orig_descriptions": [{"description": "Retrieve a list of all service configurations for the application, including default settings and overrides.", "source_files": ["live_multiple"]}, {"description": "Retrieve all service configurations for the application, including database settings, external service integration details, and feature flags.", "source_files": ["live_multiple"]}, {"description": "Retrieve the configuration settings for all services managed by the application.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": [], "properties": {"service_name": {"type": "string", "description": "The name of the specific service to retrieve configurations for, such as 'database' or 'cache'. If omitted, configurations for all services will be returned.", "default": "all"}, "include_defaults": {"type": "boolean", "description": "A flag to determine whether to include the application's default service configurations in the response.", "default": true}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": [], "properties": {"environment": {"type": "string", "description": "The deployment environment for which the service configurations are requested, such as 'development', 'staging', or 'production'.", "enum": ["development", "staging", "production"], "default": "production"}, "include_sensitive": {"type": "boolean", "description": "A flag to determine whether sensitive information like passwords and API keys should be included in the configurations.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": [], "properties": {"service_name": {"type": "string", "description": "The name of the service to filter the configurations. If omitted, configurations for all services are returned.", "default": "all"}, "include_sensitive": {"type": "boolean", "description": "Flag to determine if sensitive information such as passwords or tokens should be included in the configurations.", "default": false}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 3, "num_conversations": 3, "num_as_ground_truth": 0, "aug_description": "Use this tool to read configuration settings for services in the application. It returns a list of service configurations, including both default settings and any overrides that have been applied. Call this when the user wants to inspect or audit how services are currently configured, compare defaults vs overrides, or determine what effective settings are in use.\n\nThis tool is read-only: it does not create, update, or delete configurations and does not apply changes. It does not filter by specific service or setting; it retrieves all available service configurations for the application context implied by the caller. If the user is asking to modify settings or enable/disable features, do not use this tool. Prefer this tool when the intent is to view or list configuration state across services rather than to manage or test them.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:37+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "d7a068ff0fcfc94db4d9dbec184a93e35f8c7eb8e2834e981cacb1371c7aa1ce"}}
{"tool_name": "ApplicationSettingsApi.order_service_config", "orig_descriptions": [{"description": "Configure the order of services for an application according to specified preferences.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["service_order"], "properties": {"service_order": {"type": "array", "items": {"type": "string"}, "description": "An ordered list of service identifiers that define the sequence in which services should be arranged."}, "user_id": {"type": "integer", "description": "The unique identifier of the user for whom the service order is being configured.", "default": null}, "preserve_existing": {"type": "boolean", "description": "A flag indicating whether to preserve the existing service order if one exists. If set to 'false', the existing order will be overwritten.", "default": true}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Configure or update the ordering of services used by an application based on given preferences. Use this tool when the user wants to change how services are prioritized, sequenced, or arranged for a specific application context, such as deciding which service is tried first, second, etc.\n\nThis tool is about service ordering only; it does not create, delete, or modify the services themselves, and it does not change other application settings unrelated to order. It should be called when the intent is to apply a new preferred order or to replace an existing order with a different configuration.\n\nDo not use this tool for reading or inspecting current service order, testing connectivity, or managing non-order properties (like credentials, URLs, or feature flags). The caller must provide all required configuration details in the arguments so that the resulting order reflects the requested preferences for that application.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:39+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "d3bd4d39907f4c0fe380fb00d1e0aad491a05dc411d3d111acb30dbc4cb21bbf"}}
{"tool_name": "Attack", "orig_descriptions": [{"description": "Performs an automated penetration test against the specified host.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["url"], "properties": {"url": {"type": "string", "description": "The URL of the host to attack, including the protocol (e.g., 'http://example.com')."}, "attack_type": {"type": "string", "description": "The type of attack to perform.", "enum": ["SQL Injection", "Cross-site Scripting", "Denial of Service", "Brute Force"], "default": "Brute Force"}, "port": {"type": "integer", "description": "The port number to target on the host. Default is the standard port for the service.", "default": 80}, "verbose": {"type": "boolean", "description": "Flag indicating whether to run the attack in verbose mode, providing detailed output.", "default": false}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool when the user explicitly requests an automated penetration test or active security attack against a target host. The tool performs an offensive security assessment of the specified host, attempting to identify vulnerabilities by simulating real-world attacks.\n\nThis tool should be chosen only when the user clearly wants to test security defenses or exploitability of a given host that they are authorized to assess. It is not for passive scanning, log analysis, code review, configuration advice, or general security questions. Do not use it for theoretical risk discussions or when the user only wants best practices or guidance.\n\nBefore using this tool, the host to be tested must be clearly specified. The tool may generate traffic and interact directly with the target, so it should be invoked only in contexts where such activity is appropriate and permitted. If the intent is simply to enumerate vulnerabilities based on provided data, or to explain security concepts, use other tools instead.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:42+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "761f99682bd5df6d297904128580f387c8a6cf427b8f2015fd40814b0cd2352a"}}
{"tool_name": "B", "orig_descriptions": [{"description": "This complex function initializes a task queue with customizable concurrency, task addition, and event handling capabilities. It allows for synchronous and asynchronous task execution, pausing and resuming the queue, and handling various queue events.", "source_files": ["simple_javascript"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"e": {"type": "any", "description": "The initial task or an array of tasks to be added to the queue. Default null"}, "t": {"type": "float", "description": "The concurrency level of the task queue."}, "n": {"type": "float", "description": "The payload size for each task worker. Optional parameter. Default 0.0"}}, "required": ["t"]}, "source_files": ["simple_javascript"]}], "source_files": ["simple_javascript"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to manage and execute a series of tasks through a centralized queue with control over concurrency and execution flow. Call this when the user wants to add tasks to a queue, run them either synchronously or asynchronously, and react to queue-related events (such as tasks starting, finishing, or the queue becoming empty). It is suitable when the user needs to throttle or parallelize work, or temporarily pause and later resume processing.\n\nThis tool focuses on task flow control and event handling around queued work, not on defining what each task does internally. It does not schedule tasks based on wall-clock time, recurring schedules, or cron-like rules, and it is not for one-off, immediately executed operations that do not require queuing.\n\nChoose this tool over others when the core intent is to: (1) create or operate on a task queue, (2) configure or respect concurrency limits, (3) add tasks that may run asynchronously, and/or (4) pause, resume, or listen to events from the queue lifecycle.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:47+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "65299b981506850ed7a1309c088353fccf435c683c8f29dfd6ea15f7b079cdf4"}}
{"tool_name": "BadgeApi.get_project_policy_violations_badge1", "orig_descriptions": [{"description": "Generates a badge image indicating the number of policy violations for a specified project and version.", "source_files": ["live_multiple"]}, {"description": "Retrieves a badge indicating the policy violations status for a specified project and version.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["project_name", "project_version"], "properties": {"project_name": {"type": "string", "description": "The unique name of the project for which the badge is being requested."}, "project_version": {"type": "string", "description": "The specific version of the project to check for policy violations."}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["name", "version"], "properties": {"name": {"type": "string", "description": "The unique name identifier of the project for which the policy violations badge is requested."}, "version": {"type": "string", "description": "The version identifier of the project for which the policy violations badge is requested."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need a badge image that shows how many policy violations exist for a specific project and version. It is intended for generating a visual status badge (typically used in READMEs, dashboards, or reports) that summarizes the current violation count for that project/version combination.\n\nThis tool only generates a badge image representing the number of violations; it does not list detailed violation information, fix violations, or modify any project data. It should be chosen when the user intent is to obtain a compact, displayable image (such as for CI/CD pipelines or documentation) rather than raw policy data.\n\nCall this tool when the user explicitly asks for a policy-violation badge, a visual indicator of policy status, or an image showing violation counts for a particular project and version. Do not use it for fetching or analyzing violation details, historical trends, or non-image summaries.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:50+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "4c5d1b41788c515caf1b4fe26a88201a56f332cee4d2b7efd915c9802a40c22a"}}
{"tool_name": "BankStatementOverView", "orig_descriptions": [{"description": "Provides an overview of a bank statement, including account information and a summary of transactions for a specific period.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["bank_name", "account_number", "account_type", "full_name", "transaction_overview"], "properties": {"bank_name": {"type": "string", "description": "The official name of the bank as it appears on the bank statement."}, "account_number": {"type": "string", "description": "The unique identifier for the account, typically found at the top of the statement."}, "account_type": {"type": "string", "description": "The classification of the account, such as 'checking', 'savings', or 'credit'.", "enum": ["checking", "savings", "credit", "loan", "investment"]}, "full_name": {"type": "string", "description": "The complete name of the account holder as recorded by the bank."}, "transaction_overview": {"type": "dict", "description": "A summary of transactions within the statement period, including totals and counts.", "properties": {"total_deposits": {"type": "float", "description": "The total amount deposited in the account during the statement period, in dollars."}, "total_withdrawals": {"type": "float", "description": "The total amount withdrawn from the account during the statement period, in dollars."}, "start_date": {"type": "string", "description": "The starting date of the statement period, in the format 'YYYY-MM-DD'."}, "end_date": {"type": "string", "description": "The ending date of the statement period, in the format 'YYYY-MM-DD'."}}}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use BankStatementOverView when the user wants a high-level understanding of a bank statement for a defined time period. This tool should be chosen when the intent is to summarize, not to analyze individual transactions in depth or modify any data. It focuses on overall account information (such as account identifiers and basic details) and an aggregated view of activity in the specified period, such as total inflows, outflows, and counts or categories of transactions.\n\nDo not use this tool for tasks like reconciling specific entries, detecting fraud on individual transactions, performing budgeting or forecasting, or retrieving raw transaction lists without summarization. It is not for editing or generating statements, only for describing an existing one at a summary level.\n\nTypical triggers: the user asks for a summary of their statement, wants an overview of how their account performed over a month or other period, or needs a concise picture of their banking activity rather than line-by-line detail.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:52+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "b38fd47e60f33cf9270f48e49ebc8c7f12ec68cbfeba2a94215a3b724b51b3b9"}}
{"tool_name": "BaseMarkupSerializer.surrogates", "orig_descriptions": [{"description": "Processes surrogate pairs in XML content, ensuring they are valid XML characters and serializes them appropriately, handling cases both inside and outside of CDATA sections.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"high": {"type": "integer", "description": "The high surrogate value of the surrogate pair."}, "low": {"type": "integer", "description": "The low surrogate value of the surrogate pair."}, "inContent": {"type": "boolean", "description": "A flag indicating whether the surrogate pair is within XML content."}}, "required": ["high", "low", "inContent"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Processes and serializes Unicode surrogate pairs in XML content. Use this tool when you need to validate and correctly serialize characters represented by surrogate pairs, making sure they are allowed XML characters and are emitted in a safe form.\n\nThis tool focuses specifically on surrogate pairs and their correctness with respect to XML character rules. It ensures proper handling both inside and outside CDATA sections, maintaining well-formed XML.\n\nDo not use this tool for general XML parsing, tree manipulation, namespace handling, or attribute/element serialization that does not involve surrogate pairs. It does not create or modify XML structure; it only processes character data that may contain surrogate pairs and prepares it for XML output.\n\nTypical user intent: you already have XML text content or character data and need to ensure that any surrogate pairs it contains are valid and serialized correctly so the resulting XML remains well-formed and standards-compliant.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:54+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "f430c12e6413ae3b41689ac5c7fe053dea9964b040296b2619db3780d0ab3283"}}
{"tool_name": "BasePolicyDataProvider.getRegistryPolicyValue", "orig_descriptions": [{"description": "Retrieves the value of a specified property from the DBeaver registry policy node if it exists, specifically for Windows systems.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"root": {"type": "any", "description": "The root key in the Windows registry (e.g., HKEY_LOCAL_MACHINE)."}, "property": {"type": "String", "description": "The name of the property to retrieve the value for from the registry."}}, "required": ["root", "property"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to read a configuration or policy value from the DBeaver registry policy node on a Windows system. It retrieves the value of a single specified property, if that property exists in the registry policy location used by DBeaver. This tool is intended only for lookup of existing registry-based policy entries; it does not create, modify, or delete any registry keys or values. It should be called when the user intent is to determine how a particular DBeaver policy is configured at the system level on Windows. If the requested property does not exist in the registry policy node, the tool will indicate that no value is available rather than inferring or computing one. Do not use this tool for non-Windows environments, for reading general application preferences, or for accessing arbitrary registry paths outside the DBeaver policy node.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:57+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "f01f286809ec486559b2e1dab9b78d82f8a1811085d3498cadf39849e8fee919"}}
{"tool_name": "Basic.checkSizes", "orig_descriptions": [{"description": "Checks if the sizes of various views of the environment map match the expected size and if the map's empty status is consistent with the expected size.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"environ": {"type": "HashMap", "description": "The environment variable map to check."}, "size": {"type": "integer", "description": "The expected size of the environment variable map."}}, "required": ["environ", "size"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use Basic.checkSizes to validate that all stored views of the environment map are dimensionally consistent with a single expected size and that the map empty/non-empty state matches what that size implies. Call this tool when you need to verify internal size consistency of environment map representations, for example after loading, resizing, or transforming the map, or before performing operations that assume a specific map size. This tool does not modify the map, compute new sizes, or infer an expected size on its own; it only checks against the already defined expected size and current empty status. It does not perform geometric, semantic, or content validation beyond size and emptiness consistency. Choose this tool when the user intent is to confirm that all map views are correctly sized and that the empty flag is logically coherent with those sizes, not when you need to change, analyze, or render the map.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:32:59+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "d8c9ace05bf391c916c80f6e011f0db30d7f1167b6bc6a6b338838d691cb26c3"}}
{"tool_name": "BattleReignGameAPI.update_player_equipment", "orig_descriptions": [{"description": "Modify the player's equipment level for specified attributes", "source_files": ["parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"attribute": {"type": "string", "description": "The attribute of the equipment to modify."}, "level": {"type": "integer", "description": "The level to modify the attribute to."}, "playerID": {"type": "integer", "description": "Player ID of the player. Default to 123", "default": 123}}, "required": ["attribute", "level"]}, "source_files": ["parallel_multiple"]}], "source_files": ["parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 3, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to change a player's equipment level for specific attributes in BattleReign. It is intended for updating existing equipment stats, such as increasing or decreasing levels tied to defined attributes on a player, not for creating new equipment, deleting equipment, or changing unrelated player data.\n\nTypical use cases include applying rewards or penalties that adjust equipment levels, syncing equipment levels after gameplay events, or correcting attribute levels for a particular piece of equipment. Call this tool only when the primary goal is to modify the level values associated with equipment attributes for a known player and known equipment.\n\nDo not use this tool to modify non-equipment aspects of the player (such as experience, currency, or inventory contents) and do not use it to fetch current equipment information. It performs an update action based on the arguments you supply and assumes that the player and relevant equipment/attributes already exist in the system.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:02+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "3fa5b06262e9e7a9b5f9169fa00200b5043b56e369558ec5a93777d6ed355f1a"}}
{"tool_name": "BoardGameGeek.recommend", "orig_descriptions": [{"description": "Generate game recommendation from BoardGameGeek store based on number of players and category.", "source_files": ["multiple", "parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"numPlayers": {"type": "integer", "description": "The number of players who will play the game."}, "category": {"type": "string", "description": "The preferred category of board game. E.g. strategy, family, party etc."}, "difficulty": {"type": "string", "description": "Preferred difficulty level. E.g. beginner, intermediate, advanced etc. This is an optional parameter. Default 'beginner'"}}, "required": ["numPlayers", "category"]}, "source_files": ["multiple"]}, {"parameters": {"type": "dict", "properties": {"numPlayers": {"type": "integer", "description": "The number of players who will play the game."}, "category": {"type": "string", "description": "The preferred category of board game. E.g. strategy, family, party etc."}, "difficulty": {"type": "string", "description": "Preferred difficulty level. E.g. beginner, intermediate, advanced etc. This is an optional parameter. Default to 'beginner' if not specified."}}, "required": ["numPlayers", "category"]}, "source_files": ["parallel_multiple"]}], "source_files": ["multiple", "parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 5, "num_conversations": 2, "num_as_ground_truth": 3, "aug_description": "Use this tool when the user wants a board game recommendation tailored to their situation using data from the BoardGameGeek store. It selects games based primarily on the desired number of players and game category. This is appropriate when the user has some idea of player count and general type of game they want (for example, party, strategy, family), and is asking for a specific game or a short list of suggested games.\n\nThis tool does not search for or retrieve detailed information about a specific known game, does not manage collections, and does not analyze existing owned games. It also does not consider factors not represented in the arguments, such as game length or complexity, unless they are implicitly tied to category.\n\nCall this tool instead of generic search tools whenever the core intent is: \"Recommend me a board game from BoardGameGeek for X players in Y category.\"", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:04+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "2a3de751ddef747fcadd00983eabbb019f0287cab597d8d28c1fdeb93c35c89e"}}
{"tool_name": "Booleans.parseBooleanLenient", "orig_descriptions": [{"description": "Parses a string to a boolean value leniently, allowing various string representations to be interpreted as 'false', and defaults to 'true' for other cases, unless a default value is provided.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"value": {"type": "String", "description": "The string value to parse into a boolean."}, "defaultValue": {"type": "boolean", "description": "The default boolean value to return if the string value is null."}}, "required": ["value", "defaultValue"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Parses text into a boolean in a permissive, non-strict way. Use this tool when user input or free-form text needs to be interpreted as a boolean without failing on unexpected values. It recognizes several string forms that should clearly mean false (for example, typical negations), and returns false for them. For all other non-null, non-false-like strings, it returns true by default, unless a caller-specified default value is provided and applies. This tool is appropriate when you want a best-effort boolean from ambiguous or loosely formatted input, rather than strict validation. It does not perform numeric parsing, logical operations, or validation beyond mapping known false-like strings to false and everything else to true or a provided default.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:06+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "6739c5685739b2f7385c871d42fbbcdf0f51ad13359f225967df36ec1870f989"}}
{"tool_name": "Buses_3_BuyBusTicket", "orig_descriptions": [{"description": "This function processes the purchase of bus tickets from a departure city to a destination city on a specified date and time. It also accounts for the number of passengers and additional luggage options.", "source_files": ["live_multiple"]}, {"description": "Purchase bus tickets for a specified route, date, and time with the option to include additional luggage.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Purchases bus tickets from a specified departure city to a given destination on a set date and time, with the option to include additional luggage.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Facilitates the purchase of bus tickets from one city to another on a specified date and time, with an option for additional luggage.", "source_files": ["live_multiple"]}, {"description": "Purchase bus tickets for a specified route, date, and time. Options for the number of passengers and additional luggage are available.", "source_files": ["live_multiple"]}, {"description": "This function processes the purchase of bus tickets from a specified departure city to a destination city on a given date and time, for a certain number of passengers with an option to include additional luggage.", "source_files": ["live_multiple"]}, {"description": "This function enables the user to purchase bus tickets by providing details such as departure and destination cities, departure date and time, the number of passengers, and the option to carry additional luggage.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time", "num_passengers"], "properties": {"from_city": {"type": "string", "description": "The city where the journey begins, in the format of 'City, State', such as 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city for the trip, in the format of 'City, State', such as 'Los Angeles, CA'."}, "departure_date": {"type": "string", "description": "The departure date in 'YYYY-MM-DD' format, for example, '2023-04-21'."}, "departure_time": {"type": "string", "description": "The time of departure in 24-hour format 'HH:MM', such as '14:30' for 2:30 PM."}, "num_passengers": {"type": "integer", "description": "The number of passengers for whom the tickets are being purchased. Must be a positive integer."}, "additional_luggage": {"type": "boolean", "description": "Indicates whether additional luggage will be carried on the bus.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city of origin for the trip, such as 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city for the trip, such as 'Boston, MA'."}, "departure_date": {"type": "string", "description": "The date of departure in the format 'YYYY-MM-DD'."}, "departure_time": {"type": "string", "description": "The time of departure in 24-hour format 'HH:MM'."}, "num_passengers": {"type": "integer", "description": "The number of passengers for whom the tickets are being purchased.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "Indicates whether additional luggage space is required.", "default": false}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city to depart from, e.g., 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city of the trip, e.g., 'Los Angeles, CA'."}, "departure_date": {"type": "string", "description": "The date of departure in the format of 'YYYY-MM-DD'."}, "departure_time": {"type": "string", "description": "The time of departure in 24-hour format, e.g., '14:00'."}, "num_passengers": {"type": "integer", "description": "The number of tickets for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "Whether to carry excess baggage in the bus. True for yes, false for no.", "default": false}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city from which the bus will depart."}, "to_city": {"type": "string", "description": "The destination city for the bus trip."}, "departure_date": {"type": "string", "description": "The departure date for the trip, in the format 'YYYY-MM-DD'."}, "departure_time": {"type": "string", "description": "The departure time for the trip, in the format 'HH:MM' (24-hour clock)."}, "num_passengers": {"type": "integer", "description": "The number of passengers for whom tickets need to be purchased.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "Indicates whether additional luggage will be carried on the bus.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city to depart from, such as 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city of the trip, such as 'Boston, MA'."}, "departure_date": {"type": "string", "description": "The date of departure, in the format of 'YYYY-MM-DD'."}, "departure_time": {"type": "string", "description": "The time of departure, in 24-hour format 'HH:MM'."}, "num_passengers": {"type": "integer", "description": "The number of tickets for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "An option to carry excess baggage in the bus.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city where the journey will start, in the format of 'City, State', such as 'Berkeley, CA' and 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city for the trip, in the format of 'City, State', such as 'Los Angeles, CA' and 'Chicago, IL'."}, "departure_date": {"type": "string", "description": "The date of departure, in the format of 'YYYY-MM-DD', such as '2023-04-15'."}, "departure_time": {"type": "string", "description": "The time of departure in 24-hour format, such as '14:00' for 2 PM."}, "num_passengers": {"type": "integer", "description": "The number of passengers for whom the tickets are to be purchased.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "Indicator of whether additional luggage will be carried on the bus.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date", "departure_time"], "properties": {"from_city": {"type": "string", "description": "The city where the journey will start. The city name should be in the format of 'City, State', such as 'Los Angeles, CA'."}, "to_city": {"type": "string", "description": "The destination city of the trip. The city name should be in the format of 'City, State', such as 'New York, NY'."}, "departure_date": {"type": "string", "description": "The date of departure, in the format of 'YYYY-MM-DD'."}, "departure_time": {"type": "string", "description": "The time of departure, in the 24-hour format 'HH:MM'."}, "num_passengers": {"type": "integer", "description": "The number of tickets to purchase for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "additional_luggage": {"type": "boolean", "description": "Indicates whether the passenger will carry additional luggage beyond the standard allowance.", "default": false}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 69, "num_conversations": 66, "num_as_ground_truth": 3, "aug_description": "Use this tool when the user explicitly wants to buy or book bus tickets, not just check schedules or prices. Buses_3_BuyBusTicket handles creating a bus ticket purchase for a trip from a specific departure city to a specific destination city on a chosen date and time. It should be called only after the user has decided to proceed with a purchase and provided concrete travel details such as route, travel date and time, number of passengers, and any extra luggage needs.\n\nThis tool focuses on the purchase action itself: confirming the selected trip and applying the requested passenger count and luggage options. It does not search for routes, compare fares, or show alternatives; another tool should be used for discovery or planning if the user is still exploring options. Prefer this tool when the user intent is to finalize and process a bus ticket purchase for a defined itinerary and passenger group, including luggage selection.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:08+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "a598ef0f4d4062d3724e9fc25ab558c2cda8e6d63c212a76b0e313d0d599e881"}}
{"tool_name": "Buses_3_FindBus", "orig_descriptions": [{"description": "Search for a bus itinerary between two cities on a specific date.", "source_files": ["live_multiple"]}, {"description": "Search for a bus itinerary between two specified cities on a given date.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Search for a bus itinerary between two cities on a specified date, considering the number of passengers and route category.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Searches for bus itineraries between two cities on a specified date and accommodates a certain number of passengers.", "source_files": ["live_multiple"]}, {"description": "Search for a bus itinerary between two cities on a specified date. The search can be filtered based on the number of passengers and the bus route category.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city of departure, in the format 'City, State', such as 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city of the trip, in the format 'City, State', such as 'Los Angeles, CA'."}, "departure_date": {"type": "string", "description": "The date of departure in the format 'YYYY-MM-DD'."}, "num_passengers": {"type": "integer", "description": "The number of passengers for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The category of the trip based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city to depart from, in the format of 'City, State' (e.g., 'Los Angeles, CA')."}, "to_city": {"type": "string", "description": "The destination city of the trip, in the format of 'City, State' (e.g., 'New York, NY')."}, "departure_date": {"type": "string", "description": "The date of departure, in the format 'YYYY-MM-DD' (e.g., '2023-04-15')."}, "num_passengers": {"type": "integer", "description": "The number of tickets required for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The type of bus route based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The name of the city where the journey begins, such as 'New York, NY'."}, "to_city": {"type": "string", "description": "The destination city for the trip, such as 'Los Angeles, CA'."}, "departure_date": {"type": "string", "description": "The departure date for the trip, in the format 'YYYY-MM-DD'."}, "num_passengers": {"type": "integer", "description": "The number of passengers traveling, ranging from 1 to 5.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The category of the bus route based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city to depart from, in the format of 'City, State', such as 'Austin, TX'."}, "to_city": {"type": "string", "description": "The destination city of the trip, in the format of 'City, State', such as 'Dallas, TX'."}, "departure_date": {"type": "string", "description": "The date of departure in the format 'YYYY-MM-DD', such as '2023-04-15'."}, "num_passengers": {"type": "integer", "description": "The number of passengers for whom tickets are to be booked. Must be a positive integer.", "default": 1}, "category": {"type": "string", "description": "The category of the bus trip based on the number of stops en route.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city of departure, in the format of 'City, State', such as 'Berkeley, CA'."}, "to_city": {"type": "string", "description": "The destination city of the trip, in the format of 'City, State', such as 'Los Angeles, CA'."}, "departure_date": {"type": "string", "description": "The date of departure in the format of 'YYYY-MM-DD', such as '2023-04-15'."}, "num_passengers": {"type": "integer", "description": "The number of passengers for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The category of the trip based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city of departure, formatted as 'City, State' (e.g., 'San Francisco, CA')."}, "to_city": {"type": "string", "description": "The destination city, formatted as 'City, State' (e.g., 'Los Angeles, CA')."}, "departure_date": {"type": "string", "description": "The date of departure, formatted as 'MM/DD/YYYY' (e.g., '04/25/2023')."}, "num_passengers": {"type": "integer", "description": "The number of passengers for which to book the trip. Must be an integer from 1 to 5.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The type of bus route, indicating the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city of departure, formatted as 'City, State' (e.g., 'New York, NY')."}, "to_city": {"type": "string", "description": "The destination city, formatted as 'City, State' (e.g., 'Los Angeles, CA')."}, "departure_date": {"type": "string", "description": "The date of departure in the format 'YYYY-MM-DD' (e.g., '2023-06-15')."}, "num_passengers": {"type": "integer", "description": "The number of passengers for the trip.", "enum": [1, 2, 3, 4, 5], "default": "1"}, "category": {"type": "string", "description": "The type of bus route based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The city to depart from, in the format of 'City, State (abbr)' (e.g., 'Los Angeles, CA')."}, "to_city": {"type": "string", "description": "The destination city of the trip, in the format of 'City, State (abbr)' (e.g., 'New York, NY')."}, "departure_date": {"type": "string", "description": "The date of departure, in the format 'YYYY-MM-DD' (e.g., '2023-04-15')."}, "num_passengers": {"type": "integer", "description": "The number of tickets required for the trip.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The type of bus route based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["from_city", "to_city", "departure_date"], "properties": {"from_city": {"type": "string", "description": "The name of the city where the journey begins, such as 'New York, NY'. Use short form for state"}, "to_city": {"type": "string", "description": "The destination city for the trip, such as 'Los Angeles, CA'. Use short form for state"}, "departure_date": {"type": "string", "description": "The departure date for the trip, in the format 'YYYY-MM-DD'."}, "num_passengers": {"type": "integer", "description": "The number of passengers traveling, ranging from 1 to 5.", "enum": [1, 2, 3, 4, 5], "default": 1}, "category": {"type": "string", "description": "The category of the bus route based on the number of stops.", "enum": ["direct", "one-stop"], "default": "direct"}}}, "source_files": ["live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 69, "num_conversations": 66, "num_as_ground_truth": 17, "aug_description": "Use this tool when the user wants to find or compare bus travel options between two cities for a specific calendar date. It searches scheduled bus itineraries, focusing on intercity or long-distance routes, not local city buses or other transport modes like trains or flights. Call this tool when the user provides (or clearly implies) an origin city, a destination city, and a specific travel date, and wants information such as available routes, departure and arrival times, or to know whether a bus connection exists that day.\n\nDo not use this tool for generic timetable questions without a specific date, for searching other transport types, or for booking tickets or handling payments. It is only for retrieving bus itinerary options and related schedule details between two cities on the given date so the user can evaluate possible connections.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:11+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "a6cf102429bdc150863cd7f022db13cd6c2cc8d38036af04db48001992534a87"}}
{"tool_name": "CCRUsageTransportAction.masterOperation", "orig_descriptions": [{"description": "This function gathers usage statistics of the CCR feature in Elasticsearch and sends the results to the provided ActionListener.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"task": {"type": "any", "description": "The task associated with the request."}, "request": {"type": "any", "description": "The XPackUsageRequest object containing the request details."}, "state": {"type": "any", "description": "The current cluster state."}, "listener": {"type": "any", "description": "The ActionListener that handles the response containing the usage statistics."}}, "required": ["task", "request", "state", "listener"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to collect and report usage statistics for the CCR (Cross-Cluster Replication) feature in Elasticsearch. It aggregates data about how CCR is being used and delivers the final usage information to a provided ActionListener callback.\n\nThis tool should be selected when the user intent is to query or observe CCR usage metrics, such as for monitoring, analytics, or licensing-related insights, rather than to manage or modify CCR configurations, set up replication, or perform index operations.\n\nThe tool does not configure CCR, start or stop replication, change cluster settings, or manipulate indices. It only gathers existing usage data and reports it asynchronously via the given listener.\n\nChoose this tool over others if the request clearly involves CCR feature usage statistics or metrics, and the result is expected to be returned through an ActionListener mechanism rather than directly to the caller.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:13+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "d4edb9ef525fab51f5b5a92fe2904f80b0673ae7434b43358b1aa775d14af09e"}}
{"tool_name": "CCSDuelIT.parseEntity", "orig_descriptions": [{"description": "Parses an HttpEntity using the provided entity parser function and parser configuration, and returns the parsed response of type Resp.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"entity": {"type": "any", "description": "The HttpEntity to parse."}, "entityParser": {"type": "any", "description": "The function that will parse the XContentParser into the desired response type."}, "parserConfig": {"type": "any", "description": "The configuration for the XContentParser."}}, "required": ["entity", "entityParser", "parserConfig"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Parses an HttpEntity into a typed response using a caller-provided parser function and parser configuration.\n\nUse CCSDuelIT.parseEntity when you already have an HttpEntity and need to convert its contents into a structured result (Resp) according to custom parsing rules. The tool delegates the actual interpretation of the entity (e.g., JSON, XML, text, binary) to the supplied parser function and uses the parser configuration to control parsing behavior.\n\nThis tool does not perform the HTTP request itself, does not create or modify the HttpEntity, and does not handle networking, retries, or error recovery beyond invoking the parser as configured. It only focuses on transforming an existing HttpEntity into a domain-specific Resp value.\n\nChoose this tool when the user intent is to interpret or decode the body of an HTTP response that has already been obtained, especially when custom parsing logic or configuration needs to be applied.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:16+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "aaecb8438866a95e677454b6ad227bc3b64fd587656d8d9163ea3f998d934089"}}
{"tool_name": "CalcProduct", "orig_descriptions": [{"description": "Calculates the product of two numeric values.", "source_files": ["live_multiple", "live_parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["a", "b"], "properties": {"a": {"type": "integer", "description": "The first multiplicand in the multiplication operation."}, "b": {"type": "integer", "description": "The second multiplicand in the multiplication operation."}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 5, "num_conversations": 4, "num_as_ground_truth": 2, "aug_description": "CalcProduct multiplies exactly two numeric inputs and returns their product as a single numeric result. Use this tool whenever the user explicitly wants multiplication of two values, such as computing areas from length and width, scaling quantities, or combining two factors. It assumes both inputs are numeric (integers, floats, or numeric strings if your system supports them) and does not validate or convert non-numeric text. CalcProduct does not add, subtract, divide, compute powers, or handle more than two inputs; if the user asks for any of those operations or for aggregation over lists or arrays, a different tool should be used. This tool also does not perform unit conversion, rounding, or formatting beyond returning the raw numeric product. Choose CalcProduct when the core intent is a straightforward two-number multiplication and no additional processing is required.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:19+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "680a2c980cce8e08640feb93a677a82e53ca23886b655be0301a8500158a2379"}}
{"tool_name": "Catphish.generate_phishing_domains", "orig_descriptions": [{"description": "Generate a list of potential phishing domains based on the provided domain to help identify possible phishing attacks.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["domain"], "properties": {"domain": {"type": "string", "description": "The target domain for which to generate possible phishing variants."}, "tld": {"type": "string", "description": "The top-level domain to be used for generating phishing domains, such as 'com', 'org', 'net'.", "enum": ["com", "org", "net", "info", "biz"], "default": "com"}, "strategy": {"type": "string", "description": "The strategy to use for generating phishing domains, such as 'typo' for typographical errors or 'homoglyph' for similar-looking characters.", "enum": ["typo", "homoglyph", "subdomain", "hyphenation"], "default": "typo"}, "limit": {"type": "integer", "description": "The maximum number of phishing domain variants to generate.", "default": 10}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to generate a list of domains that could plausibly be used for phishing based on a single, legitimate target domain. Call this when the user wants to anticipate or investigate lookalike or deceptive domains that attackers might register (for example, for brand impersonation, credential harvesting, or fraud detection).\n\nThis tool focuses on creating variant domain names (such as with character substitutions, additions, or other manipulations) that resemble the provided domain. It does not check DNS records, WHOIS data, certificate information, or whether any domain is actually registered, live, or currently involved in attacks.\n\nChoose this tool when the main goal is to enumerate possible phishing-style domain variants from one known domain so they can be reviewed, monitored, or blocked elsewhere. Do not use this tool for general domain analysis, reputation scoring, or network scanning; it only generates candidate phishing domains derived from the input domain string.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:22+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "a71ee2a214bdceb2d83bc284ea50f3358dcfb5149f7bfde5493477ee47325436"}}
{"tool_name": "ChaDri.change_drink", "orig_descriptions": [{"description": "Modifies the existing drink order to accommodate the customer's new request, ensuring the drink is updated according to the specified preferences.", "source_files": ["live_multiple", "live_parallel_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["new_preferences"], "properties": {"drink_id": {"type": "string", "description": "The unique identifier of the drink to be changed.", "default": "0000-0000-0000"}, "new_preferences": {"type": "dict", "description": "The updated preferences for the drink order.", "properties": {"size": {"type": "string", "description": "The size of the drink the customer prefers.", "enum": ["small", "medium", "large"], "default": "medium"}, "temperature": {"type": "string", "description": "The temperature at which the drink should be served.", "enum": ["cold", "warm", "hot"], "default": "cold"}, "sweetness_level": {"type": "string", "description": "The sweetness level the customer requests for the drink.", "enum": ["none", "light", "regular", "extra"], "default": "regular"}, "milk_type": {"type": "string", "description": "The type of milk to be used in the drink, if applicable.", "enum": ["regular", "soy", "almond", "coconut"], "default": "regular"}, "special_instructions": {"type": "string", "description": "Any additional instructions provided by the customer for the drink preparation.", "default": ""}}}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["drink_id", "new_preferences"], "properties": {"drink_id": {"type": "string", "description": "The unique identifier of the drink to be changed."}, "new_preferences": {"type": "dict", "description": "The updated preferences for the drink order.", "properties": {"size": {"type": "string", "description": "The size of the drink the customer prefers.", "enum": ["small", "medium", "large"], "default": "medium"}, "temperature": {"type": "string", "description": "The temperature at which the drink should be served.", "enum": ["cold", "warm", "hot"], "default": "cold"}, "sweetness_level": {"type": "string", "description": "The sweetness level the customer requests for the drink.", "enum": ["none", "light", "regular", "extra"], "default": "regular"}, "milk_type": {"type": "string", "description": "The type of milk to be used in the drink, if applicable.", "enum": ["regular", "soy", "almond", "coconut"], "default": "regular"}, "special_instructions": {"type": "string", "description": "Any additional instructions provided by the customer for the drink preparation.", "default": ""}}}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 4, "num_conversations": 3, "num_as_ground_truth": 3, "aug_description": "Use this tool when the customer wants to change details of a drink that has already been ordered, rather than creating a new drink from scratch. It should be called to update an existing drink order so it matches newly specified preferences, such as different size, ingredients, add-ons, or preparation style, as long as those preferences are provided in the current context.\n\nThis tool does not place a new order, cancel an order, or modify food or non-drink items. It only adjusts an existing drink order to reflect updated customer instructions. Before calling this tool, you should already know which drink in the order is being modified and what the new preferences are. If the user is describing a brand-new drink with no prior order to change, do not use this tool; use the tool intended for creating a new drink order instead.\n\nTypical user intents include: changing a latte to oat milk, updating size, removing or adding syrup, or altering ice level for a drink that has already been ordered.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:24+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "8ac821f8b9c5811d42639870e78cc36e685225e0d7b3d5df5ebc21d3e5ca5914"}}
{"tool_name": "ChaFod", "orig_descriptions": [{"description": "Changes the food item based on the customer's request, allowing for modifications to the ingredients or preparation method.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Changes the selection of food based on the customer's request, ensuring the food name provided is in uppercase as per the requirement.", "source_files": ["live_simple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["foodItem"], "properties": {"foodItem": {"type": "string", "description": "The name of the food item to be modified as requested by the customer."}, "newIngredients": {"type": "string", "description": "A comma-separated list of new ingredients to include in the food item, if any.", "default": ""}, "removeIngredients": {"type": "string", "description": "A comma-separated list of ingredients to remove from the food item, if any.", "default": ""}, "specialInstructions": {"type": "string", "description": "Special preparation instructions provided by the customer, such as 'extra spicy' or 'no salt'.", "default": ""}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["TheFod"], "properties": {"TheFod": {"type": "string", "description": "The name of the food to be changed, provided in uppercase letters only (e.g., 'PIZZA', 'BURGER').", "enum": ["PIZZA", "BURGER", "SALAD", "SOUP", "STEAK"]}}}, "source_files": ["live_simple"]}], "source_files": ["live_multiple", "live_parallel_multiple", "live_simple"], "task_types": ["single_turn"], "num_occurrences": 8, "num_conversations": 7, "num_as_ground_truth": 5, "aug_description": "ChaFod is used when a customer explicitly wants to change an existing food item, not to create a new order or choose from a menu. Call this tool when the user requests modifications to a dish they already have or have selected, such as adding, removing, or substituting ingredients, changing portion size, or altering the preparation or cooking method.\n\nUse ChaFod for intents like: remove onions from my burger, make it extra spicy, change the pasta to gluten-free, or grill it instead of frying. The focus is on customizing or adjusting a current food item according to customer preferences or dietary needs.\n\nDo not use this tool to place an initial order, browse options, manage payment, delivery, or table reservations. It does not handle non-food changes (such as seat changes or billing details). Use ChaFod only when the main goal is to update how a specific food item is composed or prepared based on the customers stated request.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:27+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "1c40dd97c1937a8eb2a2550d336c463e926f01854ca6a83cbf059d1a19ff617a"}}
{"tool_name": "ChartSeriesGenerator", "orig_descriptions": [{"description": "This function creates a new ChartSeries with customizable settings for axis labels, data points, and color schemes, and attaches it to a given chart layout.", "source_files": ["simple_javascript"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"labels": {"type": "array", "items": {"type": "String"}, "description": "The labels for the chart's axis."}, "data": {"type": "array", "items": {"type": "String"}, "description": "The data points for the series."}, "color": {"type": "String", "description": "The default color for the series. Optional parameter."}, "chartLayout": {"type": "dict", "description": "The layout object of the chart where the series will be added."}}, "required": ["labels", "data", "chartLayout"]}, "source_files": ["simple_javascript"]}], "source_files": ["simple_javascript"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "ChartSeriesGenerator is used to create and attach a new data series to an existing chart layout. Call this tool when the user wants to add a new line, bar, or similar series to a chart, with control over axis labels, the underlying data points, and visual color styling. It focuses on defining how a single series looks and is labeled within an already defined chart layout, not on creating the entire chart or managing global chart settings. Use this tool when the intent is to: (1) introduce an additional series to a chart, (2) customize that series labels along the axes, (3) specify the numeric or categorical data points it should display, or (4) adjust its color scheme for clarity or distinction from other series. Do not use this tool for editing existing series, changing overall chart type, or configuring chart-wide options such as title, legend layout, or global theme.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:29+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "3752d287492305108350b31c24af757a60646333c440a0aeaae6ff247ae794a3"}}
{"tool_name": "ClassFileFinder.findClassFile", "orig_descriptions": [{"description": "Finds the class file for a given class name within the specified class path and returns the path to the class file.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"name": {"type": "String", "description": "The fully qualified name of the class to find."}, "classPath": {"type": "String", "description": "The class path where to search for the class file, with paths separated by the system path separator."}}, "required": ["name", "classPath"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to locate a compiled .class file for a specific Java class name within a given class path. It is appropriate when the user provides a class name and wants the corresponding class file location, for tasks like inspection, loading, or verification of compiled classes.\n\nThe tool searches only within the supplied class path context and returns the path to the matching class file. It does not compile source code, interpret Java, analyze bytecode contents, or modify any files. It also does not search outside the provided class path or resolve dependencies beyond finding the single requested class file.\n\nChoose this tool when the intent is: \"Given this fully qualified class name and a class path, tell me where the .class file is located.\" Do not use it for operations on JAR contents beyond locating the class file path, for building projects, or for running code.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:31+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "200522114668d92c92291832e2851161008d1d65e6ed88a6b6a208333e18ac03"}}
{"tool_name": "ClientAddress.set_address", "orig_descriptions": [{"description": "Sets the full address for a client profile.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["full_address"], "properties": {"full_address": {"type": "string", "description": "The complete address of the client, including street, city, state, and postal code, in the format 'Street, City, State, Postal Code' (e.g., '1234 Elm St, Springfield, IL, 62704')."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to set or update the complete postal address in a client profile when you already have all address components available and want to store them as one full address string. This tool is appropriate when the user intent is to define or overwrite the main address record for a client, for example during onboarding, profile editing, or data correction.\n\nThis tool should be chosen when the focus is on the clients physical or mailing location, not on contact details like phone numbers, emails, or other profile attributes. It does not validate or geocode the address, does not split the address into components, and does not handle multiple addresses (such as billing vs. shipping) unless the surrounding system logic associates this call with a specific address type.\n\nCall this tool when the user explicitly states a new address, wants their address changed, or requests that their profile reflect a specific full address string, including any street, unit, city, region, postal code, and country information as applicable.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:35+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "9e137c7e44da408850a2f9495de9cc844705c640bc00317324437b1a272e423b"}}
{"tool_name": "Cloudflare_Bypass", "orig_descriptions": [{"description": "This tool is used to bypass Cloudflare protection in order to retrieve the true IP address of a webpage.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["domain"], "properties": {"domain": {"type": "string", "description": "The domain whose true IP address needs to be retrieved."}, "user_agent": {"type": "string", "description": "The User-Agent string to be used in the header of the request. It represents the device and browser that is making the request.", "default": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"}, "timeout": {"type": "integer", "description": "The timeout value for the request in seconds.", "default": 30}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Cloudflare_Bypass is used when a user wants to discover the true underlying IP address of a website that is protected by Cloudflare. Call this tool if the user explicitly asks to bypass Cloudflare, uncover a server's real IP, or get origin host information that is hidden behind Cloudflare's protection.\n\nThis tool focuses only on revealing the real IP of a Cloudflare-protected target. It does not perform general web scraping, content retrieval, vulnerability scanning, DDoS, traffic generation, or any other kind of attack or load testing. It also does not configure DNS, change Cloudflare settings, or provide security analysis.\n\nUse this tool specifically when the goal is origin IP discovery behind Cloudflare and not when the user only wants page content, performance data, or standard HTTP responses, which should be handled by other HTTP or browsing tools.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:38+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "a41dd420e8fff54c8d4090327cb3e7d57d73080a4856c0d40b936613b5efe4f5"}}
{"tool_name": "CompositeRuntimeField.createChildRuntimeField", "orig_descriptions": [{"description": "Attempts to create a child runtime field for a composite field, but since composite fields cannot have children, it throws an IllegalArgumentException.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"parserContext": {"type": "any", "description": "The context used for parsing the mapping."}, "parent": {"type": "String", "description": "The name of the parent field."}, "parentScriptFactory": {"type": "any", "description": "A factory function to create a script for the parent composite field."}, "onScriptError": {"type": "any", "description": "The strategy for handling script errors."}}, "required": ["parserContext", "parent", "parentScriptFactory", "onScriptError"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use CompositeRuntimeField.createChildRuntimeField when the model is considering creating a child runtime field under a composite runtime field. This method does not actually create a child field; instead, it always fails by throwing an IllegalArgumentException because composite runtime fields are not allowed to have children.\n\nCall this tool only when the user intent is specifically about adding or defining a nested or child runtime field on top of an existing composite runtime field, and the behavior to surface is that such an operation is invalid. Do not use this tool to create normal runtime fields, to modify existing fields, or to manage non-composite fields.\n\nIf the user asks whether a composite field can have children, or tries to configure subfields under a composite runtime field, this tool is appropriate to indicate that the operation is unsupported and will result in an error.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:40+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "5db8ccd2b92ce371efb27d7f580ff194845217951637656db9d7cc2694a0574f"}}
{"tool_name": "ConsoleAnnotator.annotate", "orig_descriptions": [{"description": "Processes the given MarkupText for the specified context using a chain of ConsoleAnnotators, updating or removing annotators as necessary.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"context": {"type": "any", "description": "The context in which the MarkupText is being annotated."}, "text": {"type": "any", "description": "The MarkupText to be annotated."}}, "required": ["context", "text"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to process and transform MarkupText associated with a specific context by running it through a chain of ConsoleAnnotators. It is intended for situations where text displayed in a console-like environment needs annotation, decoration, or modification based on contextual rules.\n\nThe tool takes existing MarkupText and a context (such as a logical location, state, or usage scenario) and applies the configured ConsoleAnnotators in sequence. During this process, the chain of annotators may be updated (for example, reconfigured or reordered) or some annotators may be removed if they are no longer applicable to the given context.\n\nThis tool does not create new contexts, does not manage non-console UI elements, and does not perform generic text formatting unrelated to the ConsoleAnnotator chain. Call this when you need context-aware console text annotation or need to adapt the active annotators based on how and where the MarkupText is being used.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:43+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "6813926c47820b76f7c30878a590834887b6eec0380e059f7796e3357ea2101a"}}
{"tool_name": "ControlAppliance.execute", "orig_descriptions": [{"description": "This function is designed for controlling a home appliance, checking its current status and settings, as well as monitoring indoor air properties like air quality and temperature. For control commands, the input must clearly specify 'power on' or 'start'. To check the status, the input must include the keyword ''. Note that this tool is not intended for describing, creating, deleting, or removing modes or routines.", "source_files": ["live_multiple", "live_parallel_multiple"]}, {"description": "Controls a home appliance, checks its current status and settings, and monitors indoor air properties such as air quality and temperature. The command must be explicit, using 'power on' or 'start' for control actions and 'check' for status inquiries. Mode or routine management is not supported by this function.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["command"], "properties": {"command": {"type": "string", "description": "The command must be specified as a string in Korean, consisting of the room name, appliance name (or alias), and operation command, separated by commas. Examples: ', , ' for turning on the air conditioner in the living room, ', ,  ' for activating cooling without specifying the room, ', , ' for stopping the washing machine (alias '') in the utility room.", "enum": [", , ", ", ,  ", ", , "]}}}, "source_files": ["live_multiple", "live_parallel_multiple"]}, {"parameters": {"type": "dict", "required": ["command"], "properties": {"command": {"type": "string", "description": "The operation command for an appliance, optionally preceded by a room name and followed by the appliance name or alias. The command should be separated by commas. For example, 'main room, air conditioner, turn on' to power on the air conditioner in the main room, 'None, air conditioner, cool' to set the air conditioner to cool mode without specifying a room, and 'laundry room, tongdonly, stop' to stop the tongdonly appliance in the laundry room.", "enum": ["power on", "start", "stop", "check", "turn on", "cool"]}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple", "live_parallel_multiple"], "task_types": ["single_turn"], "num_occurrences": 22, "num_conversations": 19, "num_as_ground_truth": 7, "aug_description": "ControlAppliance.execute is used to interact with an existing home appliance: issuing control commands, checking its current status and settings, and monitoring indoor air properties (such as air quality and temperature). Use this tool when the user wants to operate an already-registered appliance (for example, turn it on or start it) or ask about its current operation or indoor environment.\n\nFor control commands, the user input text must clearly contain either the phrase 'power on' or 'start'; otherwise, do not treat it as a control request. For status inquiries, the input must contain the Korean keyword ''. If neither of these appear, this tool should generally not be called.\n\nDo NOT use this tool to describe appliances, explain features, or manage modes or routines. It must not be used to create, delete, rename, or modify modes, scenes, or routines, and it does not configure new appliances or accounts. It only operates and checks existing appliances and their indoor air readings.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:46+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "ec8d069d4b47161ea6405f14eaabb57787c4b9415a47ec7df1424e7051547c3a"}}
{"tool_name": "CookieHeaderTest.create", "orig_descriptions": [{"description": "Creates a DummyServer instance with SSL support using the provided socket address and SSL context.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"sa": {"type": "any", "description": "The socket address to bind the server to. This is an InetSocketAddress object that has a constructor taking first field as ip address, such as 192.168.1.1, as a string and taking second field is socket address such as 8000"}, "sslContext": {"type": "any", "description": "The SSL context to be used for creating the server socket. "}}, "required": ["sa", "sslContext"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to create a new DummyServer instance that supports SSL, based on a specific network endpoint and SSL configuration. It initializes a server that listens on the given socket address and uses the provided SSL context to handle secure connections. This is typically used in test or development scenarios where you need an HTTPS-like server to validate behavior such as cookie handling, headers, or other HTTP/SSL-related features.\n\nThis tool only creates and returns the DummyServer instance; it does not send requests, perform HTTP client operations, manage cookies itself, or run arbitrary test logic. Choose this tool when your goal is to set up an SSL-capable dummy server for subsequent use by other code or tools that will perform the actual interactions with that server.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:48+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "2648e3e5782ae65450dc76ea6e07bdb63120089b5ffaaea3b566fd15088df5bc"}}
{"tool_name": "CoroutineManager.co_exit_to", "orig_descriptions": [{"description": "This function switches the execution from one coroutine to another within the CoroutineManager, passing an argument object to the target coroutine. It also checks if the target coroutine is available and throws an exception if not.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"arg_object": {"type": "any", "description": "The argument object to pass to the target coroutine."}, "thisCoroutine": {"type": "integer", "description": "The ID of the currently active coroutine."}, "toCoroutine": {"type": "integer", "description": "The ID of the coroutine to switch to."}}, "required": ["arg_object", "thisCoroutine", "toCoroutine"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use CoroutineManager.co_exit_to to immediately transfer execution from the currently running coroutine to a different, already-registered coroutine managed by CoroutineManager, while passing a single argument object to the target coroutine. This is a control-flow operation: it does not create, start, or register new coroutines, and it does not resume finished or unavailable coroutines. The tool should be chosen when the user intent is to perform a direct context switch to a specific coroutine and supply it with data in one step, rather than returning to a scheduler or caller first. Before switching, the function validates that the target coroutine exists and is in a state that can accept control; if not, it raises an exception instead of silently failing. Do not use this tool to schedule new coroutines, cancel coroutines, or query coroutine status; use it strictly to exit the current coroutine context and enter another designated coroutine with an accompanying argument object.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:51+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "c93373ad62a51c46989a38eb12ce5e68f098d21d558ac3a4995ea9e24859a12f"}}
{"tool_name": "Crawler.scan", "orig_descriptions": [{"description": "Scans the specified host to retrieve information about its web directories and parameters used when a user requests specific details about domain directories.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["host"], "properties": {"host": {"type": "string", "description": "The domain name or IP address of the host to be scanned."}, "port": {"type": "integer", "description": "The port number to connect to on the host, default is HTTP port 80.", "default": 80}, "timeout": {"type": "float", "description": "The timeout for the scan in seconds. If not specified, defaults to 10 seconds.", "default": 10.0}, "user_agent": {"type": "string", "description": "The User-Agent string to be used in the HTTP requests during the scan. Defaults to a standard web browser User-Agent string.", "default": "Mozilla/5.0 (compatible; CrawlerBot/2.1)"}, "follow_redirects": {"type": "boolean", "description": "Determines whether to follow HTTP redirects (3xx responses). Defaults to true.", "default": true}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Scans the target host to discover and enumerate web-accessible directories and the parameters seen in URLs when users request specific directory-related resources.\n\nUse Crawler.scan when the user wants structural information about a website, such as paths, folders, or query-style parameters associated with those paths. This tool is for exploring how a domain is organized at the URL level (e.g., which directories exist and what parameters are commonly used with them), not for fetching page content, executing arbitrary HTTP requests, performing security testing, or analyzing data from other protocols.\n\nTypical intents include: mapping a sites directory tree, identifying available subpaths, and listing parameters that appear in requests tied to those directories. It operates at the host/domain level and focuses on web directory and parameter discovery rather than content scraping or detailed page analysis.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:53+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "388c77c6977662f286e7dca380f2659991593cc1dbbd6b15032dda09b603ab95"}}
{"tool_name": "Crypto_tool.encrypt_decrypt", "orig_descriptions": [{"description": "Encrypt, encode, and decode text using a specified cryptographic method and encoding type.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["text", "method"], "properties": {"text": {"type": "string", "description": "The text to be encrypted, encoded, or decoded."}, "key": {"type": "string", "description": "The secret key used for encryption. Must be a string of appropriate length for the chosen encryption method.", "default": "defaultkey123"}, "crypto": {"type": "string", "description": "The type of encryption algorithm to use.", "enum": ["AES", "DES", "3DES", "RSA"], "default": "AES"}, "mode": {"type": "string", "description": "The encryption mode to use with the cryptographic algorithm.", "enum": ["CBC", "CFB", "OFB", "CTR", "ECB", "GCM"], "default": "CBC"}, "method": {"type": "string", "description": "The operation to perform: encrypting, encoding, or decoding the text.", "enum": ["encrypt", "encode", "decode"]}, "encoding": {"type": "string", "description": "The type of encoding to use for the input/output text, such as 'utf-8' or 'base64'.", "default": "utf-8"}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool when the user wants to transform text with a specified cryptographic method or encoding, such as encrypting plaintext, decrypting ciphertext, encoding, or decoding. It is intended for operations where the user explicitly refers to encryption, decryption, encoding, decoding, ciphers, or cryptographic methods.\n\nThis tool should be called when the user provides or implies: (1) input text to process, (2) a choice of cryptographic method or algorithm, and/or (3) an encoding type (for example, base encodings or similar). It can be used both to protect data (encrypt/encode) and to restore readable form (decrypt/decode), depending on the chosen mode and method.\n\nDo NOT use this tool for hashing, key generation, digital signatures, or general data transformation that is not explicitly about encryption, decryption, encoding, or decoding. It does not manage files, networks, or storage; it only operates on the provided textual content according to the selected cryptographic and encoding parameters.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:56+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "35e632bfed6ef19f134b2f857fb9962fa8eec77acfb11ec21ad98c45888997d1"}}
{"tool_name": "CustomDashboardsApi.add_custom_dashboard", "orig_descriptions": [{"description": "This function creates a new custom dashboard with a specified configuration and adds it to the system.", "source_files": ["live_multiple"]}, {"description": "This function adds a new custom dashboard to the system. It allows users to create a personalized view with widgets and data relevant to their needs.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["dashboard_name", "widgets", "layout"], "properties": {"dashboard_name": {"type": "string", "description": "The name of the custom dashboard to be created."}, "widgets": {"type": "array", "items": {"type": "string"}, "description": "A list of widget identifiers to be included in the dashboard."}, "layout": {"type": "string", "description": "The layout configuration for the dashboard.", "enum": ["grid", "freeform", "single"]}, "description": {"type": "string", "description": "A brief description of the dashboard's purpose and contents.", "default": "No description provided."}, "is_public": {"type": "boolean", "description": "A flag indicating whether the dashboard should be public or private.", "default": false}}}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "required": ["dashboard_name", "user_id"], "properties": {"dashboard_name": {"type": "string", "description": "The name of the new custom dashboard."}, "user_id": {"type": "integer", "description": "The unique identifier of the user for whom the dashboard is being created."}, "widgets": {"type": "array", "items": {"type": "string"}, "description": "A list of widget identifiers to be included in the custom dashboard.", "default": []}, "layout": {"type": "string", "description": "The layout format of the dashboard.", "enum": ["grid", "single_column", "multi_column"], "default": "grid"}, "theme": {"type": "string", "description": "The visual theme of the dashboard.", "enum": ["light", "dark"], "default": "light"}, "refresh_rate": {"type": "integer", "description": "The rate at which the dashboard data refreshes, in seconds.", "default": 60}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 2, "num_conversations": 2, "num_as_ground_truth": 0, "aug_description": "Use this tool to create and register a new custom dashboard in the system. Call it when the user wants to define a fresh dashboard layout, structure, or set of widgets and save it as a reusable dashboard entity. The tool takes a full dashboard configuration as input and stores it as a new dashboard record.\n\nThis tool does not update or delete existing dashboards, does not retrieve or list dashboards, and does not validate business meaning beyond what is provided in the configuration. It should not be used for modifying permissions, sharing settings, or real-time data queries; it only adds a dashboard definition based on the provided configuration.\n\nTypical intents include: creating a new monitoring or analytics view, onboarding a new team-specific dashboard, or programmatically setting up standard dashboards for an organization. Use this tool instead of any update or get operations whenever the goal is to add a brand-new custom dashboard to the system.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:33:58+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "bfa2a7a1c1e70022da9562c4da9487e0684d036bb154ea2bae29f9c5d8bd5e2b"}}
{"tool_name": "CustomDashboardsApi.delete_custom_dashboard", "orig_descriptions": [{"description": "Deletes a specific custom dashboard identified by its unique ID.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["customDashboardId"], "properties": {"customDashboardId": {"type": "string", "description": "The unique identifier of the custom dashboard to be deleted."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool to permanently delete an existing custom dashboard when you know its unique identifier. Call this when the user explicitly wants to remove a specific dashboard from the system, such as cleaning up unused dashboards or revoking access to a dashboard that is no longer needed.\n\nThis tool operates on exactly one dashboard at a time, identified solely by its unique ID. It does not list dashboards, search for dashboards, update dashboard properties, or create new dashboards. It also does not archive or soft-delete; the intent is removal of the targeted dashboard.\n\nChoose this tool instead of other dashboard tools when the requested action is destructive removal (delete) of a known dashboard, not retrieval, modification, or creation. The caller must ensure the ID is correct and that the user has confirmed deletion, since the operation cannot be reversed by this tool.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:34:01+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "d63a6fd3a3ab0844a90c74f7794d96772b053272964b21148c7dd2f2d43c01dc"}}
{"tool_name": "CustomDashboardsApi.get_custom_dashboard", "orig_descriptions": [{"description": "Retrieve the details of a custom dashboard by its unique identifier.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["customDashboardId"], "properties": {"customDashboardId": {"type": "string", "description": "The unique identifier of the custom dashboard to retrieve."}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 0, "aug_description": "Use this tool when you need to fetch the full details of a single existing custom dashboard, given its unique identifier. This is a read-only operation that returns information about the specified dashboard, such as its configuration and associated settings, so that you can display it, inspect it, or make decisions based on its current state.\n\nCall this tool when the user intent is to: view a specific dashboard, load a dashboard for editing in the UI, confirm that a dashboard exists, or compare the properties of one dashboard to others. The identifier you provide must correspond to an already created custom dashboard.\n\nThis tool does not create, modify, delete, or list dashboards, and it cannot search for dashboards by name, tags, or other attributes. Do not use it to update or manage dashboard contents; use it strictly to retrieve the details of one known custom dashboard by its ID.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:34:07+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "713b3d4d3fb4f2638c22ee5788c6a5c22f4590664a9589b449c3726a9c52d5d4"}}
{"tool_name": "CustomDashboardsApi.get_custom_dashboards", "orig_descriptions": [{"description": "Retrieves a list of custom dashboards that the user has access to, based on the provided query parameters.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "required": ["query"], "properties": {"query": {"type": "string", "description": "A search query string to filter accessible dashboards. Supports logical operators and field-specific filtering."}, "pageSize": {"type": "integer", "description": "The number of dashboard entries to return per page.", "default": 10}, "page": {"type": "integer", "description": "The page number to retrieve, used for paginating through large sets of dashboard entries.", "default": 1}}}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool to fetch a list of custom dashboards that the current user can access. It returns only dashboards that the user is permitted to see, filtered according to the provided query parameters (such as search criteria, filters, or pagination if available in this tool). This is a read-only operation: it does not create, update, or delete dashboards, and it does not change any permissions. Call this tool when the user wants to browse, search, or enumerate existing custom dashboards, for example to display them in a UI or to select one for further actions. Do not use this tool to retrieve details of a single known dashboard (use a more specific dashboard-by-id tool if available), to modify dashboard configuration, or to manage sharing/permissions. The primary intent is listing and filtering accessible custom dashboards for the current user context.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:34:09+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "4e037de6072a77f910a2bea6d9c4eb47e10de8d660fc9561401128f53ca601d5"}}
{"tool_name": "CustomDashboardsApi.get_shareable_api_tokens", "orig_descriptions": [{"description": "Retrieves a list of shareable API tokens associated with the custom dashboards.", "source_files": ["live_multiple"]}, {"description": "Retrieve a list of shareable API tokens associated with the user's account. This can be used to grant third-party services access to the user's dashboard data without exposing personal credentials.", "source_files": ["live_multiple"]}, {"description": "Retrieve a list of shareable API tokens associated with the user's account.", "source_files": ["live_multiple"]}, {"description": "Retrieve a list of all shareable API tokens associated with the user's account. These tokens can be used to grant access to custom dashboards.", "source_files": ["live_multiple"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "The unique identifier of the user whose API tokens are to be retrieved."}, "include_expired": {"type": "boolean", "description": "Determines whether to include expired tokens in the response.", "default": false}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {}, "required": []}, "source_files": ["live_multiple"]}, {"parameters": {"type": "dict", "properties": {"user_id": {"type": "string", "description": "The unique identifier of the user whose API tokens are to be retrieved."}, "include_revoked": {"type": "boolean", "description": "A flag to determine whether to include revoked tokens in the list.", "default": false}}, "required": ["user_id"]}, "source_files": ["live_multiple"]}], "source_files": ["live_multiple"], "task_types": ["single_turn"], "num_occurrences": 9, "num_conversations": 9, "num_as_ground_truth": 2, "aug_description": "Use this tool to list all shareable API tokens that are associated with custom dashboards. Call this when the user wants to see which tokens exist, audit or review access, or manage sharing of custom dashboards via tokens.\n\nThis tool only retrieves metadata about existing shareable API tokens. It does not create, update, delete, or revoke tokens, and it does not modify any dashboard configuration. It also does not fetch dashboard content or data; it only returns the tokens linked to those dashboards.\n\nChoose this tool instead of any dashboard content or configuration tools when the intent is specifically about viewing or enumerating the shareable API tokens for custom dashboards, such as for security review or to decide which token to use for sharing.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:34:11+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "63a965212ada8f671c92644726164dda43dcaf0c1dc7160da616cc9da4cefa5b"}}
{"tool_name": "DB2Tablespace.resolveTablespaceReference", "orig_descriptions": [{"description": "Resolves a tablespace reference, which can be a name or a direct reference, to a DB2Tablespace object using the provided data source.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"monitor": {"type": "any", "description": "The progress monitor to track the operation progress."}, "dataSource": {"type": "any", "description": "The DB2DataSource object used to access the database."}, "reference": {"type": "any", "description": "The tablespace reference, which can be a name (String) or a direct DB2Tablespace reference."}}, "required": ["monitor", "dataSource", "reference"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Resolves a DB2 tablespace reference into a concrete DB2Tablespace object using the provided data source.\n\nUse this tool when the user provides a tablespace identifier that might be either a simple name (string) or an existing direct reference/handle, and you need to work with the corresponding DB2Tablespace object. The tool interprets the given reference, looks it up in the specified data source, and returns the associated DB2Tablespace.\n\nThis tool is for disambiguating and normalizing a tablespace reference before performing further operations such as inspection, modification, or validation on that tablespace. It does not create, modify, or delete tablespaces, and it does not execute SQL or other database commands. It only resolves an existing reference to the corresponding DB2Tablespace object.\n\nChoose this tool instead of ones that manage, query, or alter tablespaces when the primary need is to convert a user-supplied tablespace reference into a usable DB2Tablespace object.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:34:13+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "fa7e89398513636b1742a961bc9a601b3d82faf574f4450e419c29e7adb85257"}}
{"tool_name": "DB2ViewBaseDepCache.prepareObjectsStatement", "orig_descriptions": [{"description": "Prepares a JDBC statement for querying metadata of a specific DB2 view in a given schema.", "source_files": ["simple_java"]}], "parameters_variants": [{"parameters": {"type": "dict", "properties": {"session": {"type": "any", "description": "The JDBCSession object representing the active database session."}, "db2ViewBase": {"type": "any", "description": "The DB2ViewBase object representing the DB2 view for which the statement is being prepared."}}, "required": ["session", "db2ViewBase"]}, "source_files": ["simple_java"]}], "source_files": ["simple_java"], "task_types": ["single_turn"], "num_occurrences": 1, "num_conversations": 1, "num_as_ground_truth": 1, "aug_description": "Use this tool when you need to create a JDBC PreparedStatement that will query metadata for a single DB2 view within a specified schema. It is intended for situations where the caller already knows the target schema and view name and wants a ready-to-execute statement, rather than manually composing SQL.\n\nThis tool focuses only on preparing the statement; it does not execute the query, fetch results, or parse metadata. The caller is responsible for setting any required JDBC parameters (if not already bound), executing the statement, and processing the ResultSet.\n\nChoose this tool instead of more generic metadata or discovery tools when your use case is narrow: obtain metadata about one known DB2 view in one known schema. Do not use it for listing all views, querying table data, or performing DDL operations such as creating or altering views.", "_rewrite_meta": {"rewriter_model": "gpt-5.1-responses", "rewritten_at_utc": "2026-01-12T20:34:18+00:00", "prompt_hash": "5f4daca31122cc9fa35fb439a96a70c3bda62822c3c0fdb760a37391232f531e", "parse_mode": "json_ok", "raw_output_hash": "f20b627efae12c2a6071a4dc719fad3042eb339f969c605be4f82161422246ad"}}
